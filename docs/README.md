# Оглавление
* [1. Термины и определения](#1-термины-и-определения)
* [2. Окружение](#2-окружение)
  * [2.1. Среда трансляции](#21-среда-трансляции)
    * [2.1.1. Структура программы](#211-структура-программы)
    * [2.1.2. Стадии трансляции](#212-стадии-трансляции)
  * [2.2. Среда исполнения](#22-среда-исполнения)
    * [2.2.1. Исполнение программы](#221-исполнение-программы)
* [3. Обозначения](#3-обозначения)
* [4. Базовые концепции](#4-базовые-концепции)
  * [4.1. Область видимости идентификаторов](#41-область-видимости-идентификаторов)
  * [4.2. Время жизни объектов](#42-время-жизни-объектов)
  * [4.3. Типы](#43-типы)
  * [4.4. Представления типов](#44-представления-типов)
  * [4.5. Совместимость типов](#45-совместимость-типов)
* [5. Преобразования типов](#5-преобразования-типов)
  * [5.1. Неявные преобразования](#51-неявные-преобразования)
  * [5.2. Категории выражений](#52-категории-выражений)
* [6. Лексические соглашения](#6-лексические-соглашения)
  * [6.1. Базовый набор символов](#61-базовый-набор-символов)
    * [6.1.1. Семантика отображения символов](#611-семантика-отображения-символов)
  * [6.2. Токены препроцессора](#62-токены-препроцессора)
  * [6.3. Токены](#63-токены)
  * [6.4. Комментарии](#64-комментарии)
  * [6.5. Имя заголовка](#65-имя-заголовка)
  * [6.6. Ключевые слова](#66-ключевые-слова)
  * [6.7. Идентификаторы](#67-идентификаторы)
  * [6.8. Литералы](#68-литералы)
    * [6.8.1. Целочисленные литералы](#681-целочисленные-литералы)
    * [6.8.2. Вещественные литералы](#682-вещественные-литералы)
    * [6.8.3. Литералы перечисления](#683-литералы-перечисления)
    * [6.8.4. Символьные литералы](#684-символьные-литералы)
    * [6.8.5. Строковые литералы](#685-строковые-литералы)
    * [6.8.6. Логические литералы](#686-логические-литералы)
  * [6.9. Пунктуаторы](#69-пунктуаторы)
* [7. Выражения](#7-выражения)
  * [7.1. Первичные выражения](#71-первичные-выражения)
  * [7.2. Постфиксные операторы](#72-постфиксные-операторы)
    * [7.2.1. Вырезка из массива](#721-вырезка-из-массива)
    * [7.2.2. Вызов функции](#722-вызов-функции)
    * [7.2.3. Выборка поля структуры](#723-выборка-поля-структуры)
    * [7.2.4 Постфиксные операторы инкремента и декремента](#724-постфиксные-операторы-инкремента-и-декремента)
  * [7.3. Унарные операторы](#73-унарные-операторы)
    * [7.3.1. Префиксные операторы инкремента и декремента](#731-префиксные-операторы-инкремента-и-декремента)
    * [7.3.2. Операторы взятия адреса и косвенного обращения](#732-операторы-взятия-адреса-и-косвенного-обращения)
    * [7.3.3. Унарные арифметические операторы](#733-унарные-арифметические-операторы)
    * [7.3.4. Унарный оператор абсолютного значения](#734-унарный-оператор-абсолютного-значения)
    * [7.3.5. Унарный оператор размера массива](#735-унарный-оператор-размера-массива)
  * [7.4. Мультипликативные операторы](#74-мультипликативные-операторы)
  * [7.5. Аддитивные операторы](#75-аддитивные-операторы)
  * [7.6. Операторы битового сдвига](#76-операторы-битового-сдвига)
  * [7.7. Операторы сравнения](#77-операторы-сравнения)
  * [7.8. Операторы равенства](#78-операторы-равенства)
  * [7.9. Оператор битовой конъюнкции](#79-оператор-битовой-конъюнкции)
  * [7.10. Оператор битовой строгой дизъюнкции](#710-оператор-битовой-строгой-дизъюнкции)
  * [7.11. Оператор битовой дизъюнкции](#711-оператор-битовой-дизъюнкции)
  * [7.12. Оператор логической конъюнкции](#712-оператор-логической-конъюнкции)
  * [7.13. Оператор логической дизъюнкции](#713-оператор-логической-дизъюнкции)
  * [7.14. Условный оператор](#714-условный-оператор)
  * [7.15. Операторы присваивания](#715-операторы-присваивания)
    * [7.15.1 Оператор простого присваивания](#7151-оператор-простого-присваивания)
    * [7.15.2 Оператор составного присваивания](#7152-оператор-составного-присваивания)
  * [7.16. Оператор последовательного вычисления](#716-оператор-последовательного-вычисления)
* [8. Константные выражения](#8-константные-выражения)
* [9. Объявления](#9-объявления)
  * [9.1. Спецификаторы типов](#91-спецификаторы-типов)
    * [9.1.1. Спецификаторы структур](#911-спецификаторы-структур)
    * [9.1.2. Спецификаторы перечислений](#912-спецификаторы-перечислений)
  * [9.2. Модификаторы типов](#92-модификаторы-типов)
  * [9.3. Объявления переменных](#93-объявления-переменных)
    * [9.3.1. Деклараторы указателей](#931-деклараторы-указателей)
    * [9.3.2. Деклараторы массивов](#932-деклараторы-массивов)
    * [9.3.3. Деклараторы массивов](#933-деклараторы-ссылок)
  * [9.4. Объявления функций](#94-объявления-функций)
  * [9.5. Определения типа](#95-определения-типа)
  * [9.6. Имена типов](#96-имена-типов)
  * [9.7. Инициализаторы](#97-инициализаторы)
  * [9.8. Спецификаторы класса хранения](#98-спецификаторы-класса-хранения)
* [10. Операторы](#10-операторы)
  * [10.1. Помеченные операторы](#101-метки)
  * [10.2. Составной оператор](#102-составной-оператор)
  * [10.3. Оператор-выражение и пустой оператор](#103-оператор-выражение-и-пустой-оператор)
  * [10.4. Операторы ветвления](#104-операторы-ветвления)
    * [10.4.1. Оператор if](#1041-оператор-if)
    * [10.4.2. Оператор switch](#1042-оператор-switch)
  * [10.5. Операторы итераций](#105-операторы-итераций)
    * [10.5.1. Оператор while](#1051-оператор-while)
    * [10.5.2. Оператор do](#1052-оператор-do)
    * [10.5.3. Оператор for](#1053-оператор-for)
  * [10.6. Операторы перехода](#106-операторы-перехода)
    * [10.6.1. Оператор continue](#1061-оператор-continue)
    * [10.6.2. Оператор break](#1062-оператор-break)
    * [10.6.3. Оператор return](#1063-оператор-return)
* [11. Глобальные определения](#11-глобальные-определения)
  * [11.1. Определения функций](#111-определения-функций)
  * [11.2. Внешние объявления объектов](#112-внешние-объявления-объектов)
* [12. Директивы препроцессора](#12-директивы-препроцессора)
  * [12.1. Условное включение](#121-условное-включение)
  * [12.2. Включение файлов](#122-включение-файлов)
  * [12.3. Макро подстановки](#123-макро-подстановки)
    * [12.3.1. Подстановка аргументов](#1231-подстановка-аргументов)
    * [12.3.2. Оператор `#`](#1232-оператор-)
    * [12.3.3. Оператор `#`](#1233-оператор-)
    * [12.3.4. Области видимости макросов](#1234-области-видимости-макросов)
  * [12.4. Вычисления выражения](#124-вычисления-выражения)
  * [12.5. Циклы](#125-циклы)
* [13. Стандартная библиотека](#13-стандартная-библиотека)
* [13.1. Функции прерывания работы программы](#131-функции-прерывания-работы-программы)
* [13.2. Функции для работы с числами](#132-функции-для-работы-с-числами)
* [13.3. Функции для работы со строками](#133-функции-для-работы-со-строками)
* [13.4. Функции для работы с потоками](#134-функции-для-работы-с-потоками)
* [13.5. Функции для работы с файлами](#135-функции-для-работы-с-файлами)
* [13.6. Функции для работы со стандартными вводом и выводом](#136-функции-для-работы-со-стандартными-вводом-и-выводом)


# 1. Термины и определения
* *аргумент* - выражение в списке, разделенном запятыми, ограниченном круглыми скобками в выражении вызова функции, или последовательность токенов препроцессора в списке, разделенном запятыми, ограниченном круглыми скобками в функциональном вызове макроса
* *поведение* - внешнее явление или действие
* *неопределенное поведение* - поведение при использовании непереносимой или ошибочной программной конструкции или ошибочных данных, для которых этот документ не предъявляет требований
* *бит* - единица хранения данных в среде исполнения, достаточно большая для хранения объекта, который может иметь одно из двух значений
* *байт* - адресная единица хранения данных среды исполнения
* *символ* - (абстрактно) член набора элементов, используемых для организации, управления или представления данных
* *символ* - однобайтовый символ
* *ограничение* - ограничение, либо синтаксическое, либо семантическое, посредством которого следует интерпретировать изложение языковых элементов
* *объект* - область хранения данных в среде исполнения, содержимое которой может представлять значения
* *параметр* - объект, объявленный как часть объявления или определения функции, который получает значение при входе в функцию, или идентификатор из списка, разделенного запятыми, заключенный в круглые скобки сразу после имени макроса в функционально-подобном определении макроса
* *значение* - точное значение содержимого объекта, когда оно интерпретируется как имеющее определенный тип
* *макрос* - токен препроцессора, задаваемый директивами `#define`, `#set` или `#macro`, который при обработке заменяется препроцессором на выражение, указанное при его объявлении


# 2. Окружение
* Транслятор переводит исходные файлы RuC и выполняет программы в двух средах системы обработки данных, которые в этом документе будут называться средой трансляции и средой исполнения. Их характеристики определяют и ограничивают результаты выполнения соответствующих программ на RuC, построенных в соответствии с синтаксическими и семантическими правилами.

## 2.1. Среда трансляции

### 2.1.1 Структура программы
- Текст программы хранится в единицах, называемых исходными файлами (или файлами препроцессора) в этом документе. Исходный файл вместе со всеми заголовками и исходными файлами, включенными с помощью директивы препроцессора #include, называется единицей перевода препроцессора. После препроцессора единица перевода препроцессора называется единицей перевода. Отдельные единицы перевода программы взаимодействуют (например) с помощью вызовов функций, идентификаторы которых имеют внешнюю связь, манипулирования объектами, идентификаторы которых имеют внешнюю связь, или манипулирования файлами данных.

### 2.1.2. Стадии трансляции
- Приоритет синтаксических правил перевода определяется следующими стадиями трансляции:
  1. Исходный файл разбивается на токены препроцессора и последовательности пробельных символов (включая комментарии). Исходный файл не должен заканчиваться токеном частичной препроцессора или частичным комментарием. Каждый комментарий заменяется одним пробелом. Символы новой строки сохраняются.
  2. Выполняются директивы препроцессора, расширяются вызовы макросов. Если последовательность символов, соответствующая синтаксису универсального имени символа, создается конкатенацией токенов, поведение не определено. Директива препроцессора #include вызывает рекурсивную обработку именованного заголовка или исходного файла с этапа 1 по этап 2. Затем все директивы повторной обработки удаляются.
  3. Каждый элемент исходного набора символов и управляющая последовательность в символьных литералах и строковых литералах преобразуются в соответствующий член набора символов выполнения.
  4. Строковые литералы, следующие друг за другом, объединяются.
  5. Пробелы, разделяющие токены, больше не имеют значения. Каждый токен препроцессора преобразуется в токен. Полученные токены синтаксически и семантически анализируются и переводятся как единица перевода.

## 2.2. Среда исполнения
- Запуск программы происходит, когда назначенная функция RuC вызывается средой исполнения. Все объекты со статическим временем жизни инициализируются перед запуском программы.
- Функция, вызываемая при запуске программы, называется *main*. Она должен быть определен с возвращаемым типом **int** (**цел**) или **void**(**пусто**) и без параметров:
```c
void main() { /* ... */ }
```
  или с одним параметром (обозначаемым здесь как argv, хотя можно использовать любые имена, поскольку они являются локальными для функции, в которой они объявлены):
```c
void main(char argv[][]) { /* ... */ }
```
- Если он объявлен, параметр функции `main` подчиняется следующим ограничениям:
  - Элементы массива с `argv[0]` по `argv[upb(argv)-1]` включительно содержат строки, которым среда исполнения присваивает значения перед запуском программы. Цель состоит в том, чтобы предоставить программе информацию, определенную до запуска программы, из другого места в размещенной среде.
  - Если значение `upb(argv)` больше нуля, строка, на которую указывает `argv[0]`, представляет имя программы; `upb(argv[0])`должно быть нулем, если имя программы недоступно в среде исполнения. Если значение `upb(argv)` больше единицы, строки, на которые указывают `argv[1]` — `argv[upb(argv)-1]`, представляют параметры программы.
  - Параметр `argv` может изменяться программой.
- В среде исполнения программа может использовать все функции, макросы, определения типов и объектов, описанные в разделе **13. Стандартная библиотека**.

### 2.2.1. Исполнение программы
- Семантические описания в этом документе описывают поведение абстрактной машины, в которой вопросы оптимизации не имеют значения.
- Предшествующая последовательность представляет собой асимметричное, транзитивное отношение между вычислениями, выполняемыми одним потоком, что порождает частичный порядок среди этих вычислений. При любых двух вычислениях A и B, если A упорядочено перед B, то выполнение A должно предшествовать выполнению B. (И наоборот, если A упорядочено до B, то B упорядочено после A.) Если A не упорядочено до или после B, то A и B не упорядочены. Вычисления A и B имеют неопределенную последовательность, когда A упорядочено либо до, либо после B, но не указано, что именно. Наличие точки следования между оценкой выражений A и B подразумевает, что каждое вычисление значения и побочный эффект, упорядочивается перед каждым вычислением значения и побочным эффектом, связанным с B.
- В абстрактной машине все выражения вычисляются в соответствии с семантикой. Фактическая реализация может не вычислять часть выражения, если она может сделать вывод, что его значение не используется и что не создаются необходимые побочные эффекты (включая любые, вызванные вызовом функции).
- Минимальные требования к реализации:
  - При завершении программы все данные, записываемые в файлы, идентичны тому результату, который был бы получен при выполнении программы в соответствии с абстрактной семантикой.
  - Динамика ввода и вывода интерактивных устройств осуществляется, как указано в разделе **13.5. Функции для работы с файлами**. Цель этих требований состоит в том, чтобы небуферизованный или линейно-буферизованный вывод появлялся как можно скорее, чтобы гарантировать, что сообщения с подсказками действительно появляются до того, как программа ожидает ввода.

# 3. Обозначения
* В используемых в этой статье обозначениях синтаксические нетерминалы обозначаются курсивом, а терминалы - жирным шрифтом. Двоеточие (:), следующее за нетерминалом, означает начало его определения. Альтернативные определения перечислены на отдельных строках, за исключением случаев, когда им предшествуют слова "one of". Опциональная синтаксическая конструкция обозначается подстрочным "opt", так что
  >`{` _expression_ ₒₚₜ `}`

  означает опциональное выражение в фигурных скобках.

# 4. Базовые концепции
## 4.1. Область видимости идентификаторов
* Идентификатор может обозначать объект, функцию, член структуры, перечисление, имя typedef. Один и тот же идентификатор может обозначать разные объекты в разных точках программы. Элемент перечисления называется _литералом перечисления_.
* Для каждого отдельного объекта, который обозначает идентификатор, этот идентификатор является видимым (т. е. может быть использован) только в пределах области текста программы, называемой _областью видимости_. Различные сущности, обозначаемые одним и тем же идентификатором, имеют разные области видимости. Существуют три вида областей видимости: файл, блок и прототип функции. (_Прототип функции_ — это объявление функции, в которой объявляются типы ее параметров.)
* Каждый идентификатор имеет **область видимости**, определяемую размещением его объявления (в деклараторе или спецификаторе типа). Если декларатор или спецификатор типа, который объявляет идентификатор, появляется за пределами любого блока или списка параметров, идентификатор имеет файловую область, которая заканчивается в конце файла. Если декларатор или спецификатор типа, который объявляет идентификатор, появляется внутри блока или в списке объявлений параметров в определении функции, идентификатор имеет область видимости блока, которая заканчивается в конце связанного блока. Если декларатор или спецификатор типа, который объявляет идентификатор, появляется в списке объявлений параметров в прототипе функции (не является частью определения функции), идентификатор имеет область видимости прототипа функции, которая заканчивается в конце декларатора функции. Если идентификатор обозначает два разных объекта, области видимости могут перекрываться. Если это так, область видимости одного объекта (внутренняя область) будет строгим подмножеством области видимости другого объекта (внешняя область). Во внутренней области идентификатор обозначает сущность, объявленную во внутренней области; сущность, объявленная во внешней области, скрыта (и не видна) во внутренней области.
* Структуры и перечисления имеют область видимости, которая начинается сразу после их появления в спецификаторе типа, который объявляет их. Каждый литерал перечисления имеет область видимости, которая начинается сразу после появления определяющего ее перечисления в списке перечисления. Любой другой идентификатор имеет область видимости, которая начинается сразу после завершения его декларатора.

## 4.2. Время жизни объектов
* Время жизни объекта — это часть выполнения программы, в течение которой для него гарантированно резервируется память. Объект существует, имеет постоянный адрес и сохраняет свое последнее сохраненное значение в течение всего времени жизни. Если на объект ссылаются вне времени его жизни, поведение не определено. Значение указателя становится неопределенным, когда объект, на который он указывает, достигает конца своего жизненного цикла.
* Время жизни объекта, не имеющего тип **массива**, его время жизни начинается в момент входа в блок, с которым он связан.
* Время жизни объекта, имеющего тип **массива**, его время жизни начинается в момент его объявления. 
* Время жизни объекта завершается в тот момент, когда выполнение связанного с ним блока завершается каким-либо образом. (Вход во вложенный блок или вызов функции приостанавливает, но не заканчивает выполнение текущего блока.) При рекурсивном входе в блок каждый раз создается новый экземпляр объекта. Начальное значение объекта не определено. Если для объекта указан декларатор, он выполняется каждый раз при достижении объявления при выполнении блока; в противном случае значение становится неопределенным каждый раз при достижении объявления.

## 4.3. Типы
* Смысл значения, хранимого в объекте или возвращаемого функцией, определен _типом_ выражения. Типы подразделяются на _объектные типы_ (типы, полностью описывающие объекты) и _неполные типы_ (типы, описывающие объекты, но которым не хватает информации для определения их размера).
* Объект _логического_ типа, определяемого ключевым словом `bool`, может хранить значения `true` и `false`.
* Объект _символьного_ типа, определяемого ключевым словом `char`, может хранить любой символ базового набора символов.
* Объект _целочисленного_ типа, определяемого ключевыми словсми `int` или `long`, может хранить целое число от -2147483648 до +2147483647.
* Символьный и целочисленный типы вместе называются _целочисленными_ типами.
* Объект _вещественного_ типа, определяемого ключевыми словами `float` или `double`, может хранить число с плавающей точкой в соответствии со стандартом [IEEE-754](https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF)
* Целочисленные и вещественные типы вместе называются _арифметическими_ типами.
* _Пустой_ тип, обозначаемый ключевым словом `void` обозначает пустое множество значений. Это неполный тип, который не может быть дополнен.
* Из перечисленных выше типов можно составить любое число _производных_ типов:
  * Тип _массива_ описывает непрерывно размещенный непустой набор объектов конкретного объектного типа, называемым _типом элемента_. Тип массива характеризуется типом элемента, но не его длиной.
  * Тип _структуры_ описывает последовательно размещенный непустой набор полей-объектов (и в некоторых случаях неполных массивов). Каждое поле именовано и имеет собственный тип.
  * Тип _функции_ описывает функцию. Функциональный тип характеризуется типом возвращаемого значения, количеством и типами параметров.
  * Тип _указателя_ может быть образован от любого типа, который будет называться _указываемым_ типом. Указательный тип описывает объект, чье значение указывает на сущность указываемого типа.
  * Тип _ссылки_ может быть образован от любого типа (кроме **указателя**), который будет называться _ссылаемым_ типом. Переменная ссылочного типа является псевдонимом переменной, используемую для инициализации ссылки. После инициализации ссылка не может быть изменена. С переменной ссылочного типа можно работать так же, как и с переменной ссылаемого типа.
  * Тип _перечисления T_ образуется при объявлении перечисления.
* Целочисленные и указательные типы вместе называются _скалярными_ типами.
* Типы массивов и структур вместе называются _агрегатными_ типами.
* Тип массива неизвестного размера является неполным типом. Для идентификатора этого типа такой тип может быть дополнен обозначением размера в объявлении этого идентификатора.
* Любой тип, упомянутый до сих пор, является _немодифицированным_ типом. Каждый немодифицированный тип имеет несколько модифицированную версию своего типа, соответствующих использованиям квалификатора `const`. модифицированные или немодифицированные версии типа — это разные типы, принадлежащие к одной и той же категории типов и имеющие одинаковые требования к представлению и выравниванию. Производный тип не уточняется квалификаторами (если они есть) типа, из которого он получен.
* Ключевое слово `null` определяет нулевой указатель (константную переменную типа _нулевой указатель_). Нулевой указатель не указывает на какой-либо объект, определение при разименовании нулевого указателя не определено.

## 4.4. Представления типов
* Объекты **целочисленного** типа хранятся как последовательность 32 бит в дополнительном коде (т.е. с наиболее значимым битом, который может быть 0 или 1, представляющим знак числа). Если число положительное, то его представление в памяти совпадает с двоичным представлением числа. Если число отрицательное, его представление в памяти получается путем инвертирования всех битов модуля числа и прибавления 1.
* Объекты **символьного** типа хранятся в памяти как объекты **целочисленного** типа, где число совпадает с номером символа в таблице Unicode.
* Для всех остальных типов представление не определяется.

## 4.5. Совместимость типов
* Два типа имеют совместимый тип, если их немодифицированные типы совпадают.

# 5. Преобразования типов

## 5.1. Неявные преобразования
* Некоторые операторы автоматически преобразуют значения операндов из одного типа в другой. В этом пункте указывается результат такого неявного преобразования.
* Преобразование значения операнда в совместимый тип не приводит к изменению значения или представления в памяти.
* Объекты **целочисленных** типов могут быть преобразованы к объектам **вещественного** типа. В таком случае, преобразуемое значение остается неизменным (однако внутреннее представление может измениться).
* Операторы, которые ожидают операнды **арифметического** типа, вызывают преобразования и возвращают типы результатов аналогичным образом. В случае, если один из операндов имеет **вещественный** тип, оба операнда будут преобразованы к **вещественному** типу, и результат выражения будет иметь **вещественный** тип. В противном случае, оба операнда будут преобразованы к **целочисленному** типу.
* Преобразование **нулевого указателя** в другой тип **указателя** дает нулевой указатель этого типа. Любые два нулевых указателя сравниваются как равные.
* Указатель на объект любого типа может быть преобразован в указатель на объект такого же **неизменяемого** типа.
* Преобразование объектов типа **перечисления** в числа описан в главе **9.1.2. Спецификаторы перечислений**.
* Функция, передаваемая в качестве аргумента в другую функцию, преобразовывается в указатель на эту функцию. Вызов этого указателя равносилен вызову преобразованной функции.


## 5.2. Категории выражений
* Каждое выражение является либо _lvalue_, либо _rvalue_.
* Вырыжание типа **lvalue** ссылается на объект.
* Результатом вызова функции, которая не возвращает ссылку, является **rvalue**. 
* [Примечание: некоторые встроенные операторы предполагают операнды **lvalue**. [Пример: все встроенные операторы присваивания ожидают, что их левые операнды будут **lvalue**. ] Другие встроенные операторы возвращают **rvalue**, а некоторые ожидают их. [Пример: унарный и бинарный + операторы ожидают аргументы **rvalue** и возвращают результаты **rvalue**. ] ]
* Всякий раз, когда **lvalue** появляется в контексте, где ожидается **rvalue**, **lvalue** преобразуется в **rvalue**.
* Значение **lvalue** для объекта необходимо для изменения объекта.
* Функции не могут быть изменены.

# 6. Лексические соглашения

## 6.1. Базовый набор символов
- В символьном литерале или строковом литерале элементы исполняемого набора символов должны быть представлены соответствующими элементами исходного набора символов или управляющими последовательностями, состоящими из обратной косой черты `\`, за которой следует один или несколько символов. 
- Базовый набор символов гарантированно включает следующие символы:
  >    `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`\
  >    `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`\
  >    `а` `б` `в` `г` `д` `е` `ж` `з` `и` `й` `к` `л` `м` `н` `о` `п` `р` `с` `т` `у` `ф` `х` `ц` `ч` `ш` `щ` `ъ` `ы` `ь` `э` `ю` `я`\
  >    `А` `Б` `В` `Г` `Д` `Е` `Ж` `З` `И` `Й` `К` `Л` `М` `Н` `О` `П` `Р` `С` `Т` `У` `Ф` `Х` `Ц` `Ч` `Ш` `Щ` `Ъ` `Ы` `Ь` `Э` `Ю` `Я`\
  >    `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\
  >    `!` `"` `#` `%` \` `(` `)` `*` `+` `,` `-` `.` `/` `:` `;` `<` `=` `>` `?` `[` `\\` `]` `^` `_` `{` `|` `}` `~` `_` `_` `_` `_`\
  а также символ пробела и управляющие символы, представляющие горизонтальный отступ и перевод строки. В исходных файлах должен быть какой-то способ указать конец каждой строки текста; этот документ рассматривает такой индикатор конца строки, как если бы это был одиночный символ новой строки. В базовом наборе символов выполнения должны быть управляющие символы, новую строку. Если в исходном файле встречаются какие-либо другие символы (кроме идентификатора, символьного литерала, строкового литерала, имени заголовка, комментарияя или токена препроцессора, который никогда не преобразуется в токен), поведение не определено.

### 6.1.1. Семантика отображения символов
- Активная позиция — это место на устройстве отображения, где должен появиться следующий символ, выводимый функцией `fputc`. Цель записи печатного символа на устройство отображения состоит в том, чтобы отобразить графическое представление этого символа в активной позиции, а затем переместить активную позицию на следующую позицию в текущей строке.
- Алфавитные управляющие последовательности, представляющие неграфические символы в наборе символов выполнения, предназначены для выполнения следующих действий на устройствах отображения:
  * `\n`, `\н` - (новая строка) Перемещает активную позицию в начальную позицию следующей строки.
  * `\t`, `\т\`- (горизонтальная табуляция) Перемещает активную позицию на следующую горизонтальную позицию табуляции в текущей строке. 

## 6.2. Токены препроцессора
* **Синтаксис**
  > _preprocessing-token_:\
  >    _header-name_\
  >    _identifier_\
  >    _literal_\
  >    _punctuator_\
  >    каждый не-пробельный символ не являющийся ничем из перечисленного выше
* **Семантика**
  * Каждый токен препроцессора, преобразованный в токен, должен иметь лексическую форму ключевого слова, идентификатора, литерала, оператора или знака препинания.
  * Токен препроцессора — это минимальный лексический элемент языка на стадиях трансляции с 1 по 5. Категории токенов препроцессора: имена заголовков, идентификаторы, литералы, директивы препроцессора или пунктуаторы и одиночные неопределенные значения. символы пробела, которые лексически не соответствуют другим категориям токенов препроцессора. Если символ ' или " соответствует последней категории, поведение не определено. Токены препроцессора могут быть разделены пробелом; он состоит из комментариев или символов пробела (пробел, горизонтальная табуляция, новая строка, вертикальная tab и form-feed), или и то, и другое. 
  * Если входной файл был проанализирован на токены препроцессора до заданного символа, следующий токен препроцессора представляет собой самую длинную последовательность символов, которая может составить токен препроцессора, даже если это приведет к сбою дальнейшего лексического анализа.

## 6.3. Токены
* **Синтаксис**
  > _token_:\
  >    _keyword_\
  >    _identifier_\
  >    _literal_\
  >    _punctuator_
* **Семантика**
  * _Токен_ — это минимальный лексический элемент языка. Категории **токенов**: _ключевые слова_, _идентификаторы_, _литералы_ и _знаки препинания_. 

## 6.4. Комментарии
* Символы `/*` начинают комментарий, который заканчивается символами `*/`. Эти комментарии не имеют степени вложенности. Символы `//` начинают комментарий, который заканчивается следующим символом новой строки. Если в таком комментарии есть 
  [Примечание: символы комментария `//`, `/*` и `*/` не имеют особого значения в `//` комментарии и обрабатываются так же, как и другие символы. Точно так же символы комментария `//` и `/*` не имеют специального значения в комментарии `/*`. ]

## 6.5. Имя заголовка
* **Синтаксис**
  > _header-name_:\
  >    `<` _h-char-sequence_ `>`\
  >    `"` _q-char-sequence_ `"`\
  > _h-char-sequence_:\
  >    _h-char_\
  >    _h-char-sequence_ _h-char_\
  > _h-char_:\
  >    любой элемент базового набора символо кроме символа новой строки и `>`\
  > _q-char-sequence_:\
  >    _q-char_\
  >    _q-char-sequence_ _q-char_\
  > _q-char_:\
  >    любой элемент базового набора символо кроме символа новой строки и `"`
* **Семантика**
  * Токены препроцессора имени заголовка должны появляться только в директиве препроцессора `#include`. Последовательности в обеих формах имен заголовков сопоставляются с заголовками или с именами внешних исходных файлов, как указано в разделе **12.2. Включение файлов**.
  * Если какой-либо из символов `'` или `\`, или одна из последовательностей символов `/*` или `//` появляется в последовательности q-символов или последовательности h-символов, или символ `"` появляется в последовательности h-символов, поведение не определено.

## 6.6. Ключевые слова
* **Синтаксис**
  > _keyword_: одно из\
  >    main    главная    MAIN    ГЛАВНАЯ\
  >    char    литера    CHAR    ЛИТЕРА\
  >    double    двойной    DOUBLE    ДВОЙНОЙ\
  >    float    вещ    FLOAT    ВЕЩ\
  >    int    цел    INT    ЦЕЛ\
  >    long    длин    LONG    ДЛИН\
  >    struct    структура    STRUCT    СТРУКТУРА\
  >    enum    перечисление    ENUM    ПЕРЕЧИСЛЕНИЕ\
  >    void    пусто    VOID    ПУСТО\
  >    file    файл    FILE    ФАЙЛ\
  >    typedef    типопр    TYPEDEF    ТИПОПР\
  >    if    если    IF    ЕСЛИ\
  >    else    иначе    ELSE    ИНАЧЕ\
  >    do    цикл    DO    ЦИКЛ\
  >    while    пока    WHILE    ПОКА\
  >    for    для    FOR    ДЛЯ\
  >    switch    выбор    SWITCH    ВЫБОР\
  >    case    случай    CASE    СЛУЧАЙ\
  >    default    умолчание    DEFAULT    УМОЛЧАНИЕ\
  >    break    выход    BREAK    ВЫХОД\
  >    continue    продолжить    CONTINUE    ПРОДОЛЖИТЬ\
  >    return    возврат    RETURN    ВОЗВРАТ\
  >    null    ничто    NULL    НИЧТО\
  >    abs    абс    ABS    АБС\
  >    upb    кол_во    UPB    КОЛ_ВО\
  >    bool    булево    BOOL    БУЛЕВО\
  >    true    истина    TRUE    ИСТИНА\
  >    false    ложь    FALSE    ЛОЖЬ\
  >    const    конст    CONST    КОНСТ
* **Семантика**
  * Вышеупомянутые токены (с учетом регистра) зарезервированы для использования в качестве ключевых слов и не должны использоваться в других целях.

## 6.7. Идентификаторы
* **Синтаксис**
  > _identifier_:\
  >    _identifier-nondigit_\
  >    _identifier_ _identifier-nondigit_\
  >    _identifier_ _digit_\
  > _identifier-nondigit_:\
  >    _nondigit_\
  > _nondigit_: одно из\
  >    `_` `a` `b` `c` `d` `e` `f` `g` `h` `i` `j` `k` `l` `m` `n` `o` `p` `q` `r` `s` `t` `u` `v` `w` `x` `y` `z`\
  >    `A` `B` `C` `D` `E` `F` `G` `H` `I` `J` `K` `L` `M` `N` `O` `P` `Q` `R` `S` `T` `U` `V` `W` `X` `Y` `Z`\
  >    `а` `б` `в` `г` `д` `е` `ж` `з` `и` `й` `к` `л` `м` `н` `о` `п` `р` `с` `т` `у` `ф` `х` `ц` `ч` `ш` `щ` `ъ` `ы` `ь` `э` `ю` `я`\
  >    `А` `Б` `В` `Г` `Д` `Е` `Ж` `З` `И` `Й` `К` `Л` `М` `Н` `О` `П` `Р` `С` `Т` `У` `Ф` `Х` `Ц` `Ч` `Ш` `Щ` `Ъ` `Ы` `Ь` `Э` `Ю` `Я`\
  > _digit_: одно из\
  >    `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`
* **Семантика**
  * Идентификатор представляет собой последовательность нецифровых символов (включая подчеркивание _, строчные и прописные латинские и кириллические буквы и другие символы) и цифр, которая обозначает один или несколько объектов, как описано в разделе **4.1. Область видимости идентификаторов**. Строчные и прописные буквы различны. Ограничения на максимальную длину идентификатора нет.

## 6.8. Литералы
* **Синтаксис**
  > _literal_:\
  >    _integer-literal_\
  >    _floating-literal_\
  >    _enumeration-literal_\
  >    _character-literal_\
  >    _string-literal_\
  >    _boolean-literal_
* **Семантика**
  * Каждый литерал имеет тип, определяемый ее формой и значением, как будет подробно описано ниже.

## 6.8.1. Целочисленные литералы
* **Синтаксис**
  > _integer-literal_:\
  >    _decimal-literal_\
  >    _octal-literal_\
  >    _hexadecimal-literal_\
  >    _bitwise-literal_\
  > _decimal-literal_:\
  >    _digit_\
  >    _decimal-prefix_ _digit_\
  >    _decimal-literal_ _digit_\
  > _octal-literal_:\
  >    _octal-prefix_ _octal-digit_\
  >    _octal-literal_ _octal-digit_\
  > _hexadecimal-literal_:\
  >    _hexadecimal-prefix_ _hexadecimal-digit_\
  >    _hexadecimal-literal_ _hexadecimal-digit_\
  > _bitwise-literal_:\
  >    _bitwise-prefix_ _bitwise-digit_\
  >    _bitwise-literal_ _bitwise-digit_\
  > _decimal-prefix_: одно из\
  >    `0d` `0D`\
  > _hexadecimal-prefix_: одно из\
  >    `0x` `0X`\
  > _octal-prefix_: одно из\
  >    `0o` `0O`\
  > _bitwise-prefix_: одно из\
  >    `0b` `0B`\
  > _octal-digit_: одно из\
  >    `0` `1` `2` `3` `4` `5` `6` `7`\
  > _hexadecimal-digit_: одно из\
  >    `0` `1` `2` `3` `4` `5` `6` `7` `8` `9`\
  >    `a` `b` `c` `d` `e` `f`\
  >    `A` `B` `C` `D` `E` `F`\
  > _bitwise-digit_: одно из\
  >    `0` `1`
* **Описание**
  * Целочисленный литерал начинается с цифры, но не имеет дробной или экспоненциальной части. Она может иметь префикс, указывающий её основание.
  * Десятичный литерал начинается с цифры или с префикса `0d` или `0D`, за которыми следует последовательность цифр. Восьмеричный литерал состоит из префикса `0o` или `0O`, за которым следует последовательность цифр от 0 до 7. Шестнадцатеричный литерал состоит из префикса `0x` или `0X`, за которым следует последовательность десятичных цифр и букв от a до f (или от A до F) со значениями от 10 до 15 соответственно. Двоичный литерал состоит из префикса `0b` или `0B`, за которым следует последовательность цифр 0 и 1.
* **Семантика**
  * Значение десятичного литерала вычисляется по основанию 10; восьмеричного литерала по основанию 8; шестнадцатеричного литерала по основанию 16; двоичного литерала по основанию 2.  Лексически первая цифра является наиболее значимой.
  * Целочисленный литерал имеет **целочисленный** тип. В случае, если целочисленный литерал не входит в ограничения **целочисленного** типа, она преобразуется в **вещественный** литерал.

## 6.8.2. Вещественные литералы
* **Синтаксис**
  > _floating-literal_:\
  >    _fractional-literal_ _exponent-part_ ₒₚₜ\
  >    _digit-sequence_ _exponent-part_\
  > _fractional-literal_:\
  >    _digit-sequence_ ₒₚₜ `.` _digit-sequence_\
  >    _digit-sequence_ `.`\
  > _exponent-part_:\
  >    `e` _sign_ ₒₚₜ _digit-sequence_\
  >    `E` _sign_ ₒₚₜ _digit-sequence_\
  >    `е` _sign_ ₒₚₜ _digit-sequence_\
  >    `Е` _sign_ ₒₚₜ _digit-sequence_\
  > _sign_: одно из\
  >    `+` `-`\
  > _digit-sequence_:\
  >    _digit_\
  >    _digit-sequence_ _digit_
* **Описание**
  * Вещественный литерал имеет значащую часть, за которой может следовать показатель степени. Компоненты значащей части могут включать последовательность цифр, представляющую целую часть числа, за которой следует `.`, за которой следует последовательность цифр, представляющая дробную часть. Компонентами экспоненциальной части являются `e`, `E`, за которыми следует показатель степени, состоящий из последовательности цифр со знаком (или без знака). Должны присутствовать либо дробная часть, либо показатель степени.
* **Семантика**
  * Значимая часть интерпретируется как рациональное число; последовательность цифр в экспоненциальной части интерпретируется как десятичное целое число. Показатель степени указывает степень 10, на которую должна быть масштабирована значимая часть.
  * Вещественнй литерал имеет **вещественный** тип.
  * Вещественные литералы преобразуются во внутренний формат во время трансляции. Преобразование литерала с плавающей запятой не вызывает исключительное состояние или исключение для чисел с плавающей запятой во время выполнения.

## 6.8.3. Литералы перечисления
* **Синтаксис**
  > _enumeration-literal_:\
  >    _identifier_
* **Семантика**
  * Идентификатор, объявленный как литерал перечисления, имеет тип **константы перечесления T**, где T - перечисление, в котором объявлен данный литерал.

## 6.8.4. Символьные литералы
* **Синтаксис**
  > _character-literal_:\
  >    `'` _c-char `'`\
  > _c-char_:\
  >    любой элемент базового набора символо кроме `'`, `\`, и управляющей последовательности символа новой строки\
  > _escape-sequence_: одно из\
  >    `\'` `\"` `\\`\
  >    `\n` `\н` `\t` `\т` `\0`
* **Описание**
  * Символьный литерал представляет собой последовательность из одного или нескольких символов, заключенных в одинарные кавычки. За некоторыми исключениями, подробно описанными ниже, элементы последовательности являются любыми членами исходного набора символов.
  * Значение управляющихпоследовательностей:
    * `\'` - одинарная кавычка `'`
    * `\"` - двойная кавычка `"`
    * `\\` - обратная косая черта `\`
    * `\n`, `\н` - символ новой строки
    * `\t`, `\т\`- символ табуляции
    * `\0` - символ с кодом 0
  * Символьный литерал имеет **символьный** тип. Значение символьного литерала является числовым значением представления отображаемого символа.
  * **TOOD** каким именно образом символу сопоставляется число

## 6.8.5. Строковые литералы
* **Синтаксис**
  > _string-literal_:\
  >    `"` _s-char-sequence_ ₒₚₜ `"`\
  > _s-char-sequence_:\
  >    _s-char_\
  >    _s-char-sequence_ _s-char_\
  > _s-char_:\
  >    любой элемент базового набора символо кроме `"`, `\`, и управляющей последовательности символа новой строки\
* **Описание**
  * Строковый литерал — это последовательность из нуля или более символов, заключенная в двойные кавычки.
  * К каждому элементу последовательности в строковом литерале применяются те же соображения, как если бы он был символьным литералом, за исключением того, что одинарная кавычка `'` может быть представлена либо сама по себе, либо с помощью управляющая последовательность `\'`, но двойная кавычка `"` должна быть представлена управляющей последовательностью `\"`.
* **Семантика**
  * Строковый литерал имеет тип **массив элементов символьного типа**.

## 6.8.6. Логические литералы
* **Синтаксис**
  > _boolean-literal_:\
  >    `true`\
  >    `false`
* **Описание**
  * Логические литералы — это ключевые слова `false` и `true`. Такие литералы имеют **логический** тип. Они не являются **lvalue**.

## 6.9. Пунктуаторы
* **Синтаксис**
  > _punctuator_: одно из\
  >    `[` `]` `(` `)` `{` `}` `.` `->`\
  >    `++` `--` `&` `*` `+` `-` `˜` `!`\
  >    `/` `%` `<<` `>>` `<` `>` `<=` `>=` `==` `!=` `ˆ` `|` `&&` `||`\
  >    `?` `:` `;` `...`\
  >    `=` `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `&=` `ˆ=` `|=`\
  >    `,` `#`\
* **Семантика**
  * Пунктуатор – это набор символов, имеющий самостоятельное синтаксическое и семантическое значение. В зависимости от контекста, он может задавать операцию, которая должна быть выполнена (которая, в свою очередь, может дать значение или указатель функции, произвести побочный эффект или некоторую их комбинацию), и в этом случае он известен как _оператор_ (другие формы оператора также существуют в некоторых контекстах). _Операнд_ — это сущность, над которой действует оператор.

# 7. Выражения <!-- TODO примеры ко всем выражениям >
* _Выражение_ - последовательность операторов и операндов, задающая вычисление значения, указывающая на объект или функцию, генерирующая побочный эффект или любые комбинации из вышеперечисленного.
* Группировка операндов и операторов (то есть приоритет операторов) задаются синтаксисом. Порядок вычисления операндов определен только для операторов вызова `()`, логической конъюнкции `&&`, логической дизъюнкции `||`, условного оператора `?:` и оператора последовательного исполнения `,`. В прочих случаях порядок вычисления операндов не определен.
* Если во время вычисления выражения возникает _исключительное состояние_ (например, результат математически не определен или не может быть представлен значением своего типа), поведение не определено.


## 7.1. Первичные выражения
* **Синтаксис**
  > _primary-expression:_\
  >    _identifier_\
  >    _literal_\
  >    `(` _expression_ `)`
* **Семантика**
  * Идентификатор является первичным выражением, если он был объявлен как объект (в этом случае это lvalue) или как функция. Использование необъявленного идентификатора - нарушение синтаксиса.
  * Литерал является первичным выражением. Его тип зависит от вида и значения литерала, как было описано в разделе **6.8. Литералы**.
  * Выражение в круглых скобках является первичным выражением. Его тип и значение идентичны типу и значению выражению внутри скобок. Это lvalue, если выражение без скобок lvalue.


## 7.2. Постфиксные операторы
* **Синтаксис**
  > _postfix-expression:_\
  >    _primary-expression_\
  >    _postfix-expression_ `[` _expression_ `]`\
  >    _postfix-expression_ `(` _argument-expression-list_ ₒₚₜ `)`\
  >    _postfix-expression_ `.` _identifier_\
  >    _postfix-expression_ `->` _identifier_\
  >    _postfix-expression_ `++`\
  >    _postfix-expression_ `—`\
  >\
  > _argument-expression-list:_\
  >    _initializer_\
  >    _argument-expression-list_ `,` _initializer_

### 7.2.1. Вырезка из массива
* **Ограничения**
  * Первое выражение должно иметь тип **массив Т**, второе выражение должно иметь **целочисленный** тип. Результат имеет тип **Т**.
* **Семантика**
  * Постфиксное выражение, за которым следует выражение в квадратных скобках `[]` - вырезка элемента массива. Если объект `E1` был объявлен как массив, то запись `Е1[Е2]` означает элемент с индексом `Е2` (отсчитывая с нуля) массива `Е1`.
  * Последовательные операторы вырезки обозначают элемент многомерного массива.
  * В следующем примере Задаётся массив массивов целых чисел `a`. После задаётся массив `b`, в который копируется массив `a[1]`. После объявляется целочисленная переменная `c`, которой присваивается значение массива `b` по индексу 4.
```c
  int a[5][6];

  int b[] = a[1];

  int c = b[4];
```

### 7.2.2. Вызов функции
* **Ограничения**
  * Первое выражение должно иметь тип **функция, возвращающая Т**. Результат вызова имеет тип **Т**.
* **Семантика**
  * Постфиксное выражение, за которым следует разделенный запятыми список выражений (возможно пустой) в круглых скобках `()` означают вызов функции. Левое выражение обозначает вызываемую функцию. Список выражений определяет аргументы функции.
  * Аргумент должен удовлетворять условиям инициализации типа соответствующему параметру, как это описано в разделе **97. Инициализаторы**. При подготовке к вызову функции каждому параметру присваивается значение соответствующего аргумента.

### 7.2.3. Выборка поля структуры
* **Ограничения**
  * Первый операнд оператора `.` должен иметь тип **структура**. Второй операнд должен называть поле этой структуры.
  * Первый операнд оператора `->` должен иметь тип **указатель на структуру**. Второй операнд должен называть поле этой структуры, на которую указывает левый операнд.
* **Семантика**
  * Постфиксное выражение, за которым следует оператор `.`, а идентификатор называет поле структуры, обозначает поле структуры. Это lvalue, если левый операнд lvalue. Результат имеет тот же тип, который имеет поле структуры.
  * Постфиксное выражение, за которым следует оператор `->`, а идентификатор называет поле структуры, на которую указывает левый операнд, обозначает поле структуры. Это lvalue. Результат имеет тот же тип, который имеет поле структуры.
  * Если `E` - структура, то выражение `(&E)->MOS` эквивалентно `E.MOS`.

### 7.2.4. Постфиксные операторы инкремента и декремента
* **Ограничения**
  * Операнд постфиксных операторов инкремента или декремента должен иметь **арифметический** тип и быть модифицируемым lvalue.
* **Семантика**
  * Результатом постфиксного оператора `++` является значение операнда. После получения результата значение операнда увеличивается на `1`.
  * Результатом постфиксного оператора `--` является значение операнда. После получения результата значение операнда уменьшается на `1`.
  

## 7.3. Унарные операторы
* **Синтаксис**
  > _unary-expression:_\
  >    _postfix-expression_\
  >    `++` _unary-expression_\
  >    `--` _unary-expression_\
  >    _unary-operator_ _unary-expression_\
  >    _unary-func-operator_ `(` _unary-expression_ `)`\
  >\
  > _unary-operator:_ одно из\
  >    `&` `*` `-` `̃` `!`\
  > _unary-operator:_ одно из\
  >    `abs` `upb`\

### 7.3.1. Префиксные операторы инкремента и декремента
* **Ограничения**
  * Операнд префиксных операторов инкремента или декремента должен иметь **арифметический** тип и быть модифицируемым lvalue.
* **Семантика**
  * Значение операнда префиксного оператора `++` увеличивается на `1`. Результатом является новое значение операнда.
  * Значение операнда префиксного оператора `--` уменьшается на `1`. Результатом является новое значение операнда.

### 7.3.2. Операторы взятия адреса и косвенного обращения
* **Ограничения**
  * Операнд унарного оператора `&` должен быть lvalue.
  * Операнд унарного оператора `*` должен иметь тип **указатель**.
* **Семантика**
  * Унарный оператор `&` возвращает адрес своего операнда. Если операнд является результатом унарного оператора `*`, ни этот оператор, ни оператор `&` не вычисляются, и результат такой, как если бы оба были опущены, за исключением того, что ограничения на операторы все еще применяются, и результат не является lvalue. В противном случае результатом является указатель на объект, обозначенный операндом.
  * Унарный оператор `*` обозначает косвенное обращение (разыменование). Если операнд указывает на объект, результатом будет lvalue, обозначающее объект. Если операнд имеет тип **указатель на Т**, результат будет иметь тип **Т**. Если указателю присвоено недопустимое значение, поведение унарного оператора `*` не определено.

### 7.3.3. Унарные арифметические операторы
* **Ограничения**
  * Операнд унарного оператора `+` должен иметь **арифметический** тип.
  * Операнд оператора `~` должен иметь **целочисленный** тип.
  * Операнд оператора `!` должен иметь **скалярный** тип.
* **Семантика**
  * Результатом унарного оператора `-` является значение его операнда с противоположным знаком. Тип результата совпадает с типом операнда.
  * Результатом оператора `~` является побитовое дополнение операнда (то есть каждый бит в результате устанавливается тогда и только тогда, когда соответствующий бит в операнде не установлен). Результат имеет **целочисленный** тип.
  * Результатом оператора **логического отрицания** `!` является `false`, если значение операнда равно начальному значению соответствующего типа; `true` в обратном случае. Результат имеет **логический** тип.

### 7.3.4. Унарный оператор абсолютного значения
* **Ограничения**
  * Операнд унарного оператора `abs` должен иметь **арифметический** тип.
* **Семантика**
  * Результатом унарного оператора `abs` является абсолютное значение\* его операнда. Тип результата совпадает с типом операнда
  * \* Исключением является наименьшее отрицательное значение типа `int`, которое не имеет абсолютного значения. Результатом `abs` для этого значения 

### 7.3.5. Унарный оператор размера массива
* **Ограничения**
  * Операнд унарного оператора `upb` должен иметь тип **массива**.
* **Семантика**
  * Результатом унарного оператора `upb` является размер массива, являющегося его операндом.


## 7.4. Мультипликативные операторы
* **Синтаксис**
  > _multiplicative-expression:_\
  >    _unary-expression_\
  >    _multiplicative-expression_ `*` _unary-expression_\
  >    _multiplicative-expression_ `/` _unary-expression_\
  >    _multiplicative-expression_ `%` _unary-expression_
* **Ограничения**
  * Операнды операторов `*` и `/` должны иметь **арифметический** тип.
  * Операнды оператора `%` должны иметь **целочисленный** тип.
* **Семантика**
  * Результатом оператора `*` является произведение операндов.
  * Результатом оператора `/` является частное от деления первого операнда на второй; результат оператора `%` - остаток. В обеих операциях, если значение второго операнда равно нулю, поведение не определено.
  * При делении целых чисел результатом оператора `/` является алгебраическое частное с отброшенной дробной частью.


## 7.5. Аддитивные операторы
* **Синтаксис**
  > _additive-expression:_\
  >    _multiplicative-expression_\
  >    _additive-expression_ `+` _multiplicative-expression_\
  >    _additive-expression_ `-` _multiplicative-expression_
* **Ограничения**
  * Операнды операторов `+` и `-` должны иметь **арифметический** тип.
* **Семантика**
  * Результатом оператора `+` является сумма операндов.
  * Результатом оператора `-` является разность левого и правого операндов.


## 7.6. Операторы битового сдвига
* **Синтаксис**
  > _shift-expression:_\
  >    _additive-expression_\
  >    _shift-expression_ `<<` _additive-expression_\
  >    _shift-expression_ `>>` _additive-expression_
* **Ограничения**
  * Операнды операторов битового сдвига должны иметь **целочисленный** тип.
* **Семантика**
  * Результатом выражения `E1 << E2` является `E1`, сдвинутое влево на `E2` бит; освобожденные биты заполняются нулями.
  * Результатом выражения `E1 >> E2` является `E1`, сдвинутое вправо на `E2` бит; освобожденные биты заполняются старшим битом E1.


## 7.7. Операторы сравнения
* **Синтаксис**
  > _relational-expression:_\
  >    _shift-expression_\
  >    _relational-expression_ `< ` _shift-expression_\
  >    _relational-expression_ `> ` _shift-expression_\
  >    _relational-expression_ `<=` _shift-expression_\
  >    _relational-expression_ `>=` _shift-expression_
* **Ограничения**
  * Операнды операторов сравнения должны иметь **арифметический** тип.
* **Семантика**
  * Каждый из операторов `<` ("меньше"), `>` ("больше"), `<=` ("меньше или равно") и `>=` ("больше или равно") выдает `true`, если обозначенное отношение истинно, и `false`, если оно ложно. Результат имеет **логический** тип.


## 7.8. Операторы равенства
* **Синтаксис**
  > _equality-expression:_\
  >    _relational-expression_\
  >    _equality-expression_ `==` _relational-expression_\
  >    _equality-expression_ `!=` _relational-expression_
* **Ограничения**
  * Одно из следующих условий должно выполняться:
    * Оба операнда имеют **арифметический** тип;
    * Оба операнда имеют совместимые типы;
    * Один из операндов имеет тип **указатель**, а другой является литералом `null`.
* **Семантика**
  * Каждый из операторов `==` ("равно") и `!=` ("не равно") выдает `true`, если обозначенное отношение истинно, и `false`, если оно ложно. Результат имеет **логический** тип.


## 7.9. Оператор битовой конъюнкции
* **Синтаксис**
  > _and-expression:_\
  >    _equality-expression_\
  >    _and-expression_ `&` _equality-expression_
* **Ограничения**
  * Оба операнда должны иметь **целочисленный** тип.
* **Семантика**
  * Результат бинарного оператора `&` - битовая конъюнкция операндов.


## 7.10. Оператор битовой строгой дизъюнкции
* **Синтаксис**
  > _xor-expression:_\
  >    _and-expression_\
  >    _xor-expression_ `^` _and-expression_
* **Ограничения**
  * Оба операнда должны иметь **целочисленный** тип.
* **Семантика**
  * Результат бинарного оператора `^` - битовая строгая дизъюнкция операндов.


## 7.11. Оператор битовой дизъюнкции
* **Синтаксис**
  > _or-expression:_\
  >    _xor-expression_\
  >    _or-expression_ `|` _xor-expression_
* **Ограничения**
  * Оба операнда должны иметь **целочисленный** тип.
* **Семантика**
  * Результат бинарного оператора `|` - битовая дизъюнкция операндов.


## 7.12. Оператор логической конъюнкции
* **Синтаксис**
  > _logical-and-expression:_\
  >    _or-expression_\
  >    _logical-and-expression_ `&&` _or-expression_
* **Ограничения**
  * Оба операнда должны иметь **скалярный** тип.
* **Семантика**
  * Оператор `&&` выдает `true`, если оба операнда не равны начальному значению соответствующего типа; иначе оператор выдает `false`.
  * Оператор `&&` гарантирует вычисление слева направо. Если первый операнд равен начальному значению соответствующего типа, второй операнд не вычисляется.


## 7.13. Оператор логической дизъюнкции
* **Синтаксис**
  > _logical-or-expression:_\
  >    _logical-and-expression_\
  >    _logical-or-expression_ `||` _logical-and-expression_
* **Ограничения**
  * Оба операнда должны иметь **скалярный** тип.
* **Семантика**
  * Оператор `||` выдает `true`, если хотя бы один из операндов не равен начальному значению соответствующего типа; иначе оператор выдает `false`.
  * Оператор `||` гарантирует вычисление слева направо. Если первый операнд не равен начальному значению соответствующего типа, второй операнд не вычисляется.


## 7.14. Условный оператор
* **Синтаксис**
  > _conditional-expression:_\
  >    _logical-or-expression_\
  >    _logical-or-expression_ `?` _expression_ `:` _conditional-expression_
* **Ограничения**
  * Первый операнд должен иметь **скалярный** тип.
  * Одно из следующих условий должно выполняться для второго и третьего операндов:
    * Оба операнда имеют **арифметический** тип;
    * Оба операнда имеют совместимые типы;
    * Один операнд имеет тип **указатель**, а другой является литералом `null`.
* **Семантика**
  * Сначала вычисляется первый операнд. Второй операнд вычисляется только если первый операнд не равен начальному значению соответствующего типа; третий операнд вычисляется только если первый операнд равен начальному значению соответствующего типа. Результатом является значение вычисленного (второго или третьего) операнда.
  * Результирующим типом является наиболее общий тип, совместимый с типами второго и третьего операндов.


## 7.15. Операторы присваивания
* **Синтаксис**
  > _assignment-expression:_\
  >    _conditional-expression_\
  >    _unary-expression_ _assignment-operator_ _initializer_\
  >\
  > _assignment-operator:_ one of\
  >    `=` `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `&=` `ˆ=` `|=`
* **Ограничения**
  * Первый операнд оператора присваивания должен быть модифицируемым lvalue.
* **Семантика**
  * Оператор присваивания сохраняет значение в объекте, обозначенном первым операндом. Результат имеет значение и тип первого операнда после присваивания, но не является lvalue.

### 7.15.1. Оператор простого присваивания
* **Ограничения**
  * Одно из следующих условий должно выполняться:
    * Левый операнд имеет **вещественный** тип, и правый операнд имеет **целочисленный** тип;
    * Левый операнд имеет тип **указатель**, и правый операнд является литералом `null`;
    * Операнды имеют совместимые типы.
* **Семантика**
  * При _простом присваивании_ значение правого операнда конвертируется к типу присваивания и заменяет значение, хранящееся в объекте, указанном левым операндом.

### 7.15.2. Оператор составного присваивания
* **Ограничения**
  * Операнды оператора составного присваивания должны удовлетворять требованиям соответствующего бинарного оператора
* **Семантика**
  * Составное присваивание вида `E1 op= E2` отличается от простого присваивания `E1 = E1 op E2` только тем, что `E1` вычисляется только один раз.


## 7.16. Оператор последовательного вычисления
* **Синтаксис**
  > _expression:_\
  >    _assignment-expression_\
  >    _expression_ `,` _assignment-expression_
* **Семантика**
  * Сначала вычисляется левый операнд; его результат отбрасывается. Затем вычисляется правый операнд; результат имеет его тип и значение.

# 8. Константные выражения
* **Синтаксис**
  > _constant-expression:_\
  >    _conditional-expression_
* **Описание**
  * Константное выражение может быть вычислено на этапе компиляции и использовано в любом месте, где может быть литерал.
* **Ограничения**
  * Константные выражения не могут содержать присваиваний, инкрементов, декрементов и вызовов функций.
  * Каждое константное выражение должно оцениваться как константа, которая находится в диапазоне представляемых значений для его типа.
* **Семантика**
  * Выражение, результатом которого является константа, требуется в нескольких контекстах. Если выражение с плавающей запятой оценивается в среде компилятора, арифметическая точность и диапазон будут как минимум такими же большими, как если бы выражение оценивалось в среде выполнения.
  * Целочисленное константное выражение должно иметь целочисленный тип и должно иметь только операнды, являющиеся целочисленными литералами, литералами перечисления, символьными литералами.
  * Семантика вычисления константного выражения такая же, как и для неконстантных выражений.

# 9. Объявления <!-- TODO примеры ко всем объявлениям >
* **Синтаксис**
  > _declaration:_\
  >    _variable-declaration_ `;`\
  >    _function-declaration_ `;`\
  >    _type-definition_ `;`
* **Ограничения**
  * В любой области видимости должно быть не больше одного объявления идентификатора, за исключением функций, как описано в разделе **9.4. Определения функций**.
* **Семантика**
  * Объявление определяет интерпретацию набора идентификаторов. 
  * _Определение_ идентификатора – это объявление, которое:
    * для объекта приводит к выделению памяти для этого объекта;
    * для функции включает тело функции;
    * для определений типов и литералов перечисления является единственным объявлением идентификатора.

## 9.1. Спецификаторы типов
* **Синтаксис**
  > _type-specifier:_\
  >    `void`\
  >    `bool`\
  >    `char`\
  >    `short`\
  >    `int`\
  >    `long`\
  >    `float`\
  >    `double`\
  >    `FILE`\
  >    _struct-specifier_\
  >    _enum-specifier_\
  >    _typedef-name_
* **Синтаксис**
  * Сопоставление типов ключевым словам описано в разделе **4.3. Типы**.
  * Сопоставление модификаторов типов ключевым словам описано в разделе **9.2. Модификаторы типов**.
  * Спецификаторы структур описаны в разделе **9.1.1. Спецификаторы структур**.
  * Спецификаторы перечислений описаны в разделе **9.1.2. Спецификаторы перечислений**.
  * Имена определенных типов описаны в разделе **9.5. Определения типов**.

### 9.1.1. Спецификаторы структур
* **Синтаксис**
  > _struct-specifier:_\
  >    `struct` _identifier_ ₒₚₜ `{` _struct-declaration-list_ `}`\
  >    `struct` _identifier_\
  >\
  > _struct-declaration-list:_\
  >    _struct-declaration_\
  >    _struct-declaration-list_ _struct-declaration_\
  >\
  > _struct-declaration:_\
  >    _type-qualifier_ ₒₚₜ _type-specifier_ _declarator_ `;`\
  >    _function-declaration_ `;`
* **Ограничения**
  * Структура не может содержать поле **неполного** или **функционального** типа (поэтому структура не может содержать экземпляр самой себя, но может содержать указатель на экземпляр самой себя).
* **Семантика**
  * Как было описано в разделе **4.3. Типы**, структура - это тип, состоящий из последовательности полей, расположенных в памяти последовательно в обозначенном порядке.
  * Если заголовок объявления структуры содержит идентификатор, то он является именем типа этой структуры, и может использоваться как <code>_typedef-name_</code>.
  * Конструкция <code>_struct-declaration-list_</code> объявляет новый тип в соответствующей области видимости. Этот тип не является полным, пока не достигнута `}`, оканчивающая список полей структуры.

### 9.1.2. Спецификаторы перечислений
* **Синтаксис**
  > _enum-specifier:_\
  >    `enum` _identifier_ ₒₚₜ `{` _enumerator-list_ `}`\
  >    `enum` _identifier_ ₒₚₜ `{` _enumerator-list_ `,` `}`\
  >    `enum` _identifier_\
  >\
  > _enumerator-list:_\
  >    _enumerator_\
  >    _enumerator-list_ `,` _enumerator_\
  >\
  > _enumerator:_\
  >    _identifier_\
  >    _identifier_ `=` _constant-expression_
* **Ограничения**
  * Выражение, обозначающее значение литерала перечисления, должно иметь **целочисленный** тип.
* **Семантика**
  * Конструкция <code>_enumerator-list_</code> объявляет новый тип в соответствующей области видимости. Этот тип не является полным, пока не достигнута `}`, оканчивающая список литералов перечисления.
  * Если заголовок объявления перечисления содержит идентификатор, то он является именем типа этого перечисления, и может использоваться как <code>_typedef-name_</code>.
  * Идентификаторы из списка перечисления объявляются как константы типа **перечисления T**, где **T** - спецификатор перечесления, соответствующий константе. Конструкция <code>_enumerator_</code> c `=` определяет константу перечисления как значение константного выражения. Если первая конструкция <code>_enumerator_</code> в списке перечисления не имеет `=`, то значение соответствующей константы равно 0. Каждая последующая конструкция <code>_enumerator_</code> без `=` определяет константу со значением, получаемым прибавлением 1 к значению предыдущей константы. 
  * Значения констант одного и того же перечисления могут повторяться.

## 9.2. Модификаторы типов
* **Синтаксис**
  > _type-qualifier_:\
  >    `const`
* **Семантика**
* Модификатор `const` делает модифицируемый тип _неизменяемым_ (т.е. запрещает изменение значения переменной после определения). Модификатор может находиться перед типом, если это не указатель и после `*` для указателей. Примеры:
  * `const int a` - неизменяемая переменная целочисленного типа
  * `const int *b` - изменяемый указатель на неизменяемую переменную целочисленного типа
  * `int *const c` - неизменяемый указатель на изменяемую переменную целочисленного типа
  * `const int *const d` - неизменяемый указатель на неизменяемую переменную целочисленного типа

## 9.3. Объявления переменных
* **Синтаксис**
  > _variable-declaration:_\
  >    _storage-class-specifier_ ₒₚₜ _type-qualifier_ ₒₚₜ _type-specifier_ _init-declarator-list_ ₒₚₜ\
  >\
  > _init-declarator-list:_\
  >    _init-declarator_\
  >    _init-declarator-list_ `,` _init-declarator_\
  >\
  > _init-declarator:_\
  >    _declarator_\
  >    _declarator_ `=` _initializer_\
  >\
  > _declarator:_\
  >    `*` ₒₚₜ `&` ₒₚₜ _type-qualifier_ ₒₚₜ _direct-declarator_\
  >\
  > _direct-declarator:_\
  >    _identifier_\
  >    _direct-declarator_ `[` _assignment-expression_ ₒₚₜ `]`
* **Ограничения**
  * Объявление должно содержать хотя бы одно описание типа структуры или перечисления или хотя бы один декларатор.
  * К концу объявления тип объявляемого объекта должен быть полным.
  * Модификаторы типа могут быть использованы только при использовании `*`
  * `*` и `&` не могут быть использованы одновременно. 
* **Семантика**
  * Каждый декларатор объявляет один идентификатор, и для каждого его появления в выражении указывает область видимости и тип, заданный спецификаторами объявления.
  * В объявлении вида `T D`, где `T` обозначает спецификатор типа, а `D` - декларатор, содержащий некоторый идентификатор, тип, указанный для этого идентификатора, описывается индуктивно с использованием этой нотации.
  * Если в объявлении `T D`, где `T` обозначает спецификатор типа, а `D` - декларатор, `D` имеет форму <code>_identifier_</code>, то декларатор объявляет переменную с именем идентификатора и типом **T**.
  * При объявлении переменных константного и ссылочного типа должен присутствовать _initializer_.

### 9.3.1. Деклараторы указателей
* **Семантика**
  * Если в объявлении `T D1`, где `T` обозначает спецификатор типа, а `D1` - декларатор, `D1` имеет форму `*D`, и объявление `T D` задает объявляемому идентификатору тип **T**, то идентификатору задается тип **указатель на Т**.

### 9.3.2. Деклараторы массивов
* **Ограничения**
  * Если `[]` содержат выражение, то это выражение описывает размер массива и должно иметь **целочисленный** тип. Если выражение является константным, то его значение должно быть больше нуля.
  * Тип элемента в деклараторе массива не должен быть **функциональным**.
* **Семантика**
  * Если в объявлении `T D1`, где `T` обозначает спецификатор типа, а `D1` - декларатор, `D1` имеет форму `D[N]`, и объявление `T D` задает объявляемому идентификатору тип **T**, то идентификатору задается тип **массив из N элементов типа Т**, где N вычисляется при достижении данного объявления.
  * Если в объявлении `T D1`, где `T` обозначает спецификатор типа, а `D1` - декларатор, `D1` имеет форму `D[]`, и объявление `T D` задает объявляемому идентификатору тип ** T**, то идентификатору задается тип **массив элементов типа Т**, а размер будет задан инициализатором.
  * Если выражение размера массива отсутствует, то тип описанного массива является неполным. Он может быть дополнен инициализатором.
  * Когда значение выражения, обозначающего размер массива, будет вычислено, оно должно быть больше 0. Размер массива не меняется в течении всего его времени жизни.

### 9.3.3. Деклараторы ссылок 
* **Ограничения**
  * Переменная ссылочного типа должна быть инициализирована выражением lvalue при объявлении.
* **Семантика**
  * Если в объявлении `T D1`, где `T` обозначает спецификатор типа, а `D1` - декларатор, `D1` имеет форму `*D`, и объявление `T D` задает объявляемому идентификатору тип **T**, то идентификатору задается тип **ссылка на Т**.

## 9.4. Объявления функций
* **Синтаксис**
  > _function-declaration:_\
  >    _return-type-specifier_ _function-declarator_ `(` _parameter-list_ ₒₚₜ `)`\
  >\
  > _return-type-specicifier:_\
  >    _type-qualifier_ ₒₚₜ _type-specifier_ `*` ₒₚₜ\
  >    _return-type-specicifier_ `[` _constant-expression_ ₒₚₜ `]`\
  >\
  > _function-declarator:_\
  >    _identifier_\
  >    `(` `*` _identifier_ `)`\
  >\
  > _parameter-list:_\
  >    _parameter-declaration_\
  >    _parameter-list_ `,` _parameter-declaration_\
  >\
  > _parameter-declaration:_\
  >    _type-name_\
  >    _type-qualifier_ ₒₚₜ _type-specifier_ _declarator_\
  >    _function-declaration_
* **Ограничения**
  * Объявляемая функция не может возвращать значение **функционального** типа.
  * Выражение, обозначающее размер возвращаемого массива должно иметь **целочисленный** тип.
  * Объявляемая функция не может возвращать значение **неизменяемого** типа (однако может возвращать **указатель** на **неизменяемый** тип).
* **Семантика**
  * Если в объявлении `T D`, где `T` обозначает возвращаемый тип, а `D` - декларатор функции, `T` имеет форму <code>_type-specifier_</code>, то возвращаемый тип задается соответсвенно спецификатору типа, как это было описано в разделе **4.3. Типы**.
  * Если в объявлении `T1 D`, где `T1` обозначает возвращаемый тип, а `D` - декларатор функции, `T1` имеет форму `Т*`, и объявление `T` задает возвращаемый тип **T**, то возвращаемый тип задается как **указатель на Т**.
  * Если в объявлении `T1 D`, где `T1` обозначает возвращаемый тип, а `D` - декларатор функции, `T1` имеет форму `T[N]`, и `T` задает возвращаемый тип **T**, то возвращаемый тип задается как **массив из N элементов типа Т**, где N вычисляется при достижении данного объявления.
  * Если в объявлении `T1 D`, где `T1` обозначает возвращаемый тип, а `D` - декларатор функции, `T1` имеет форму `T[]`, и `T` задает возвращаемый тип **T**, то возвращаемый тип задается как **массив элементов типа Т**.
  * Если в объявлении декларатор функции имеет форму <code>_identifier_</code>, то объявление объявляет функцию с параметрами, обозначенными списком параметров и возвращающую значение такого типа, как было описано выше.
  * Если в объявлении декларатор функции имеет форму <code>`(*`_identifier_`)`</code>, то объявление объявляет указатель на функцию с параметрами, обозначенными списком параметров и возвращающую значение такого типа, как было описано выше.
  * Список параметров определяет типы и имена для параметров функции.
  * Параметр, определенный типом **функция** преобразуется в параметр с типом **указатель на функцию**.

## 9.5. Определения типов
* **Синтаксис**
  > _typedef-name:_\
  >    _identifier_
* **Семантика**
  * В объявлении, спецификатором класса хранения которого является `typedef`, каждый декларатор определяет идентификатор как имя typedef, обозначающее тип, указанный для идентификатора, способом, описанным в разделе **9.3. Объявления переменных**. Объявление typedef не вводит новый тип, а только синоним указанного таким образом типа.

## 9.6. Имена типов
* **Синтаксис**
  > _type-name:_\
  >    _variable-type-name_\
  >    _function-type-name_\
  >\
  > _variable-type-name:_\
  >    _type-qualifier_ ₒₚₜ _type-specifier_ `*` ₒₚₜ _abstract-declarator_ ₒₚₜ\
  >\
  > _abstract-declarator:_\
  >    _abstract-declarator_ ₒₚₜ `[` _assignment-expression_ ₒₚₜ `]`\
  >\
  > _function-type-name:_\
  >    _return-type-specifier_ _function-pointer_ ₒₚₜ `(` _parameter-list_ ₒₚₜ `)`\
  >\
  > _function-pointer:_\
  >    `(` `*` `)`
* **Семантика**
  * В некоторых контекстах необходимо указать тип. Это достигается при помощи конструкции _имя типа_, которая позволяет объявить объект или функцию, опуская идентификатор.

## 9.7. Инициализаторы
* **Синтаксис**
  > _initializer:_\
  >    _assignment-expression_\
  >    `{` _initializer-list_ `}`\
  >    `{` _initializer-list_ `,` `}`\
  >\
  > _initializer-list:_\
  >    _initializer_\
  >    _initializer-list_ `,` _initializer_
* **Ограничения**
  * Инициализатор для скалярного объекта должен быть одиночным выражением.
  * Инициализатор для агрегатного объекта должен быть списком инициализации, как описано ниже, либо одиночным выражением совместимого типа.
  * Если инициализатор агрегатного объекта имеет форму списка инициализации, то список должен содержать соответствующее количество подвыражений, равное количеству элементов массива или количеству полей структуры.
  * Одно из следующих условий должно выполняться для инициализируемого объекта и для инициализатора:
    * Объект имеет **вещественный** тип, и правый операнд имеет **целочисленный** тип;
    * Левый операнд имеет тип **указатель**, и правый операнд является литералом `null`;
    * Операнды имеют **совместимые** типы.
* **Семантика**
  * Инициализатор определяет начальное значение, хранимое в объекте.
  * Если объект не инициализируется явно, то:
    * если объект имеет тип **указатель**, он инициализируется константой нулевого указателя;
    * если объект имеет **арифметический** тип, он инициализируется нулем;
    * если объект имеет **агрегатный** тип, каждый его элемент инициализируется по этим правилам.
  * Каждый элемент списка инициализации инициализирует соответствующий элемент агрегатного объекта: элементы массива в порядке возрастания индекса, поля структур в порядке их объявления. Инициализация происходит в этом же порядке.
  * Если в объявлении со списком инициализации агрегатный объект содержит агрегатные объекты, то правила инициализации применяются рекурсивно для соответствующего вложенного списка.
  * Если инициализируется массив неизвестной длины, то его размер определяется количеством элементов списка инициализации. К концу инициализации массив имеет **полный** тип.

## 9.8. Спецификаторы класса хранения
* **Синтаксис**
  > _storage-class-specifier_:\
  >    `typedef`\
* **Ограничения**
  * Может быть указано не более одного спецификатора класса хранения в спецификаторах объявления в объявлении.
  * Спецификаторы класса хранения могут быть использованы только в объявлениях за пределами любого блока.
* **Семантика**
  * Спецификатор typedef называется «спецификатором класса хранения» только для синтаксического удобства; он подробно описывается в разделе **9.5. Определения типов**.

# 10. Операторы <!-- TODO примеры ко всем операторам >
* **Синтаксис**
  > _statement:_\
  >    _labeled-statement_\
  >    _compound-statement_\
  >    _expression-statement_\
  >    _selection-statement_\
  >    _iteration-statement_\
  >    _jump-statement_
* **Семантика**
  * _Оператор_ обозначает действие. Операторы исполняются последовательно.
  * _Блок_ позволяет сгруппировать набор объявлений и операторов в одну синтаксическую единицу. Значения выражений, обозначающих длины массивов, и значения инициализаторов объектов будут вычислены тогда, когда объявление будет достигнуто в порядке исполнения.

## 10.1. Метки
* **Синтаксис**
  > _labeled-statement:_\
  >    `case` _constant-expression_ `:` _statement_\
  >    `default` `:` _statement_
* **Ограничения**
  * Метки `case` и `default` должны появляться только в операторе `switch`. Прочие ограничения на эти метки описаны в разделе "Оператор switch".

## 10.2. Составной оператор
* **Синтаксис**
  > _compound-statement:_\
  >    `{` _block-item-list_ ₒₚₜ `}`\
  >\
  > _block-item-list:_\
  >    _block-item_\
  >    _block-item-list_ _block-item_\
  >\
  > _block-item:_\
  >    _declaration_\
  >    _statement_
* **Семантика**
  * _Составной оператор_ - это блок.

## 10.3. Оператор-выражение и пустой оператор
* **Синтаксис**
  > _expression-statement:_\
  >    _expression_ ₒₚₜ `;`
* **Семантика**
  * Выражение оператора-выражения вычисляется для его побочных эффектов (например, присваиваний и вызовов функций).
  * _Пустой оператор_ (состоящий только из `;`) не производит операций.
  * ПРИМЕР 1. В программе:
    ```c
    char *s;
    /* ... */
    while (*s++ != '\0')
      ;
    ```
    пустой оператор используется для предоставления пустого тела цикла оператору итерации.

## 10.4. Операторы ветвления
* **Синтаксис**
  > _selection-statement:_\
  >    `if` `(` _expression_ `)` _statement_\
  >    `if` `(` _expression_ `)` _statement_ `else` _statement_\
  >    `switch` `(` _expression_ `)` _statement_
* **Семантика**
  * _Оператор ветвления_ выбирает среди набора операторов в зависимости от значения управляющего выражения.
  * Оператор ветвления - это блок, область видимости которого является строгим подмножеством области видимости включающего его блока. Каждый вложенный оператор также является блоком, область видимости которого является строгим подмножеством области видимости оператора ветвления.

### 10.4.1. Оператор if
* **Ограничения**
  * Управляющее выражение оператора `if` должно иметь **скалярный** тип.
* **Семантика**
  * В обеих формах первый вложенный оператор исполняется, если значение управляющего выражения не равно 0. В форме `else` второй вложенный оператор исполняется, если значение управляющего выражения равно 0. Если первый вложенный оператор достигнут с помощью перехода на метку, второй вложенный оператор не исполняется.
  * `else` ассоциировано с ближайшим в лексическом смысле предыдущим `if`.

### 10.4.2. Оператор switch
* **Ограничения**
  * Управляющее выражение оператора `switch` должно иметь **целочисленный** тип.
  * Выражение каждой метки `case` должно быть **целочисленным** константным выражением и никакие два выражения меток `case` в одном операторе `switch` не должны иметь совпадающих значений после преобразований.
  * В операторе `switch` должно быть не больше одной метки `default`.
  * Вложенный оператор `switch` может иметь свою метку `default`, а значения выражений меток `case` могут дублировать значения выражений меток `case` внешнего оператора `switch`.
* **Семантика**
  * Оператор `switch` заставляет поток управления переходить к _телу оператора_, в или за него, в зависимости от значения управляющего выражения, а также от наличия метки `default` и значений любых меток `case` внутри тела оператора. Метка `case` или `default` доступна только внутри ближайшего включающего оператора `switch`.
  * Если значение выражения метки `case` совпадает со значением управляющего выражения, поток исполнения переходит к оператору, следующему за этой меткой. Если таких меток `case` нет, но есть метка `default`, поток исполнения переходит к помеченному оператору. Если значения никаких выражений меток `case` не совпадают со значением управляющего выражения, и нет метки `default`, никакая часть оператора `switch` не исполняется.
  * ПРИМЕР. В программе:
    ```c
    switch (expr) {
      int i = 4;
      f(i);
    case 0:
      i = 17;
      /* falls through into default code */
    default:
      printf("%d\n", i);
    }
    ```
    объект с идентификатором `i` не будет инициализирован. Если значение управляющего выражения не равно 0, функция `printf` обратится к неопределенному значению. Аналогично, вызов функции `f` не будет исполнен.

### 10.5. Операторы итераций
* **Синтаксис**
  > _iteration-statement:_\
  >    `while` `(` _expression_ `)` _statement_\
  >    `do` _statement_ `while` `(` _expression_ `)` `;`\
  >    `for` `(` _expression_ ₒₚₜ `;` _expression_ ₒₚₜ `;` _expression_ ₒₚₜ `)` _statement_\
  >    `for` `(` _declaration_ _expression_ ₒₚₜ `;` _expression_ ₒₚₜ `)` _statement_
* **Ограничения**
  * Управляющее выражение оператора итерации должно иметь **скалярный** тип.
* **Семантика**
  * Оператор итерации вызывает повторное выполнение оператора, называемого _телом цикла_, до тех пор, пока результат управляющего выражения не станет равным 0.
  * Оператор итерации - это блок, область видимости которого является строгим подмножеством области видимости включающего его блока. Тело цикла также является блоком, область видимости которого является строгим подмножеством области видимости оператора итерации.

### 10.5.1. Оператор while
  * Вычисление управляющего выражения происходит перед каждым исполнением тела цикла.

### 10.5.2. Оператор do
  * Вычисление управляющего выражения происходит после каждого исполнения тела цикла.

### 10.5.3. Оператор for
  * Оператор вида  
    `for` `(` _clause-1_ `;` _expression-2_ `;` _expression-3_ `)` _statement_  
    ведет себя следующим образом: выражение _expression-2_ является управляющим выражением, которое вычисляется перед каждым выполнением тела цикла. Выражение _expression-3_ вычисляется после каждого выполнения тела цикла. Если _clause-1_ является объявлением, область видимости любых объявляемых им переменных - это оставшаяся часть объявления и весь цикл, включая два других выражения; оно исполняется перед первым вычислением управляющего выражения. Если _clause-1_ является выражением, оно вычисляется перед первый вычислением управляющего выражения.
   Таким образом, _clause-1_ определяет инициализацию цикла, возможно, объявляя одну или несколько переменных для использования в цикле; управляющее выражение _expression-2_ определяет вычисление, выполняемое перед каждой итерацией, так что выполнение цикла продолжается до тех пор, пока результат выражения не станет равным 0; а _expression-3_ определяет операцию (например, инкремент), которая выполняется после каждой итерации.
  * И _clause-1_, и _expression-3_ могут быть опущены. Опущенное _expression-2_ заменяется ненулевой константой.

## 10.6. Операторы перехода
* **Синтаксис**
  > _jump-statement:_\
  >    `continue` `;`\
  >    `break` `;`\
  >    `return` _expression_ ₒₚₜ `;`
* **Семантика**
  * Оператор перехода означает безусловный переход.

### 10.6.1. Оператор continue
* **Ограничения**
  * Оператор `continue` должен появляться только в теле (или быть телом) или оператора итерации.
* **Семантика**
  * Оператор `continue` завершает исполнение текущей итерации цикла и переходит к следующей.
  * ПРИМЕР. В программе:
    ```c
    for (/* ... */) {
      /* ... */
      continue;
      /* ... */
    }
    ```
    оператор `continue` эквивалентен пропуску всех операторов, следующих от оператора `continue` до закрывающей фигурной скобки.

### 10.6.2. Оператор break
* **Ограничения**
  * Оператор `break` должен появляться только в теле (или быть телом) оператора `switch` или оператора итерации.
* **Семантика**
  * Оператор `break` завершает исполнение наименьшего по включению оператора `switch` или цикла.

### 10.6.3. Оператор return
* **Ограничения**
  * Оператор `return` с выражением не должен появляться в функции, возвращающей значение типа **void**. Оператор `return` без выражения должен появляться только в функции, возвращающей значение типа **void**.
* **Семантика**
  * Оператор `return` завершает исполнение текущей функции и возвращает управление ее вызывающей стороне. Функция может иметь любое количество операторов `return`.
  * Если исполняется оператор `return` с выражением, значение выражения возвращается вызывающей стороне как значение выражения вызова функции. Если выражение имеет тип, отличный от типа возвращаемого значения функции, в которой оно появляется, значение преобразуется, как если бы оно было присвоено объекту, имеющему тип возвращаемого значения функции.

# 11. Глобальные определения <!-- TODO примеры ко всем определениям >
* **Синтаксис**
  > _translation-unit:_\
  >    _external-declaration_\
  >    _translation-unit_ _external-declaration_\
  >\
  > _external-declaration:_\
  >    _declaration_\
  >    _function-definition_
* **Семантика**
  * Текст программы после подстановок препроцессора называется единицей трансляции и состоит из последовательности внешних объявлений. Они называются "внешними", так как находятся вне какой-либо функции.

## 11.1. Определения функций
* **Синтаксис**
  > _function-definition:_\
  >    _function-declaration_ _compound-statement_
* **Ограничения**
  * Возвращаемый тип функции должен быть **пустым** или любым **объектным** типом.
  * Если декларатор содержит список параметров, то объявление каждого параметра должно содержать имя.
* **Семантика**
  * Декларатор в определении функции обозначает имя описываемой функции и идентификаторы ее параметров.
  * Составной оператор в определении функции обозначает _тело функции_.
  * Каждый идентификатор параметра является lvalue, который фактически объявлен в начале тела функции (и потому не может быть переопределено в теле функции кроме как во включающем блоке).
  * При входе в функцию подсчитываются выражения размеров массивов, а значения каждого аргумента конвертируются к типу соответствующего параметра как если бы они были инициализированы.
  * После инициализации всех параметров исполняется тело функции.
  * Если достигнута `}`, завершающая определение функции, и значение вызова этой функции использовано вызывающим, поведение не определено.

## 11.2. Внешние объявления объектов
* **Семантика**
  * Если объявление идентификатора имеет глобальную область видимости, то оно является _внешним объявлением_ идентификатора.
  * Если внешнее объявление не содержит инициализатор, и описываемый идентификатор имеет тип, отличный от **функционального**, то идентификатор инициализируется начальным значением, как было описано в разделе **9.7. Инициализаторы**.
  * Вычисление значений внешних объектов происходит в порядке их появления в единице трансляции при запуске программы.

# 12. Директивы препроцессора <!-- TODO примеры ко всем директивам >
* **Синтаксис**
  > _preprocessing-file_:\
  >    _group_ ₒₚₜ\
  > _group_:\
  >    _group-part_\
  >    _group_ _group-part_\
  > _group-part_:\
  >    _if-section_\
  >    _control-line_\
  >    _text-line_\
  > _if-section_:\
  >    _if-group_ _elif-groups_ ₒₚₜ _else-group_ ₒₚₜ _endif-line_\
  > _if-group_:\
  >    `#` `if` _constant-expression_ _new-line_ _group_ ₒₚₜ\
  >    `#` `ifdef` _identifier_ _new-line_ _group_ ₒₚₜ\
  >    `#` `ifndef` _identifier_ _new-line_ _group_ ₒₚₜ\
  > _elif-groups_:\
  >    _elif-group_\
  >    _elif-groups_ _elif-group_\
  > _elif-group_:\
  >    `#` `elif` _constant-expression_ _new-line_ _group_ ₒₚₜ\
  > _else-group_:\
  >    `#` `else` _new-line_ _group_ ₒₚₜ\
  > _endif-line_:\
  >    `#` `endif` _new-line_\
  > _contol-line_:\
  >    `#` `include` _pp-tokens_ _new-line_\
  >    `#` _define-word_ _identifier_ _parameter-list_ ₒₚₜ\
  >                      _replacement-list_ _new-line_\
  >    `#` `undef` _identifier_ _new-line_\
  >    `#` `macro` _identifier_ _parameter-list_ ₒₚₜ _new-line_ 
  >             _group_ _endm-line_\
  >    `#` `while` _pp-tokens_ _new-line_ _group_ _endw-line_\
  >    `#` `eval` _pp-tokens_ _new-line_\
  > _test-line_:\
  >    _pp-tokens_ ₒₚₜ _new-line_\
  > _non-directive_:\
  >    _pp-tokens_ _new-line_\
  > _define-word_:\
  >    `define`\
  >    `set`\
  > _parameter-list_:\
  >    _lparen_ _identifier-list_ ₒₚₜ `)`\
  > _lparen_:\
  >    a `(` символ, за которым сразу не следует пробел\
  > _replacement-list_:\
  >    _pp-tokens_ ₒₚₜ\
  > _pp-tokens_:\
  >    _preprocessing-token_\
  >    _pp-tokens_ _preprocessing-token_\
  > _endm-line_:\
  >    `#` `endm` _new-line_\
  > _endw-line_:\
  >    `#` `endw` _new-line_\
  > _new-line_:\
  >    символ новой строки
* **Описание**
  * Директива препроцессора состоит из последовательности токенов препроцессора, которая начинается с токена препроцессора `#`, который является либо первым символом в исходном файле (необязательно после пробела, не содержащего символов новой строки), либо следует за пробелом, содержащим хотя бы один символ новой строки, и заканчивается следующим символом новой строки. Символ новой строки завершает директиву препроцессора, даже если он встречается внутри того, что в противном случае было бы вызовом макро-функции.
  * Строка исходного кода программы не должна начинаться с токена препроцессора `#`.
* **Ограничения**
  * Единственными пробельными символами, которые должны появляться между токенами препроцессора в директиве препроцессора (сразу после введения токена препроцессора # до непосредственно перед завершающим символом новой строки), являются пробел и табуляция.
* **Семантика**
  * Компилятор может условно обрабатывать и пропускать разделы исходных файлов, включать другие исходные файлы и заменять макросы. Эти возможности называются предварительной обработкой, поскольку концептуально они выполняются до компиляции исходного кода.
  * Токены препроцессора в директиве препроцессора не воспринимаются как макросы, если не указано иное.

## 12.1. Условное включение
* **Ограничения**
  * Выражение, управляющее условным включением, должно быть целочисленным константным выражением, за исключением того, что: оно не должно содержать приведение типов.
* **Семантика**
  * Предварительная обработка директив следующих форм проверяет, оценивается ли управляющее константное выражение ненулевым
  > `#` `if` _constant-expression_ _new-line_ _group_ ₒₚₜ\
  > `#` `elif` _constant-expression_ _new-line_ _group_ ₒₚₜ\
  * Перед оценкой заменяются вызовы макросов в списке токенов препроцессора, которые станут управляющим константным выражением. Полученные токены составляют управляющее константное выражение, которое оценивается в соответствии с правилами, описанными в разделе **6. Константные выражения**. Это включает в себя интерпретацию символьных констант, которая может включать преобразование escape-последовательностей в элементы набора символов выполнения.
  * Директивы препроцессора следующих форм проверяют, определен ли идентификатор в настоящее время как имя макроса
  > `#` `ifdef` _identifier_ _new-line_ _group_ ₒₚₜ\
  > `#` `ifndef` _identifier_ _new-line_ _group_ ₒₚₜ\
  * Условие каждой директивы проверяется по порядку. Если оно вычисляется как ноль, группа, которой она управляет, пропускается: директивы обрабатываются только через имя, которое определяет директиву, чтобы отслеживать уровень вложенных условных выражений; остальные токены препроцессора директив игнорируются, как и другие токены препроцессора в группе. Обрабатывается только первая группа, условие управления которой оценивается как истинное (ненулевое). Если ни одно из условий не оценивается как истинное, и есть директива #else, обрабатывается группа, управляемая директивой #else; без директивы #else все группы до #endif пропускаются.

## 12.2. Включение файлов
* **Ограничения**
  * Директива #include должна идентифицировать заголовок или исходный файл.
* **Семантика**
  * Директива препроцессора следующей формы ищет в последовательности путей, переданной компилятору через аргумент `-I`, однозначно определяемый заданной последовательностью между разделителями `<` и `>`, и вызывает замену этой директивы всем содержимым заголовка.
  > `#` `include` `<` _h-char-sequence_ `>` _new-line_\
  * Директива препроцессора следующей формы вызывает замену этой директивы всем содержимым исходного файла, идентифицируемого указанной последовательностью между разделителями `"`. Если поиск не удался, директива обрабатывается заново, как если бы вместо ограничителей `"` стояли ограничители `<` и `>`. 
  * Директива препроцессора #include может появиться в исходном файле, который был прочитан из-за директивы #include в другом файле, вплоть до предела вложенности (32).

## 12.3. Макро подстановки
* **Ограничения**
  * Между идентификатором и списком замены в определении объектно-подобного макроса должен быть пробел.
  * Количество аргументов (включая аргументы, не состоящие из токенов препроцессора) в вызове функционального макроса должно равняться количеству параметров в определении макроса. В противном случае в вызове должно быть больше аргументов, чем параметров в определении макроса. Должен существовать токен препроцессора `)`, который завершает вызов.
* **Семантика**
  * Идентификатор, следующий сразу за _define-word_, называется именем макроса. Существует одно пространство имен для имен макросов. Любые символы пробела, предшествующие или следующие за списком замены токенов препроцессора, не считаются частью списка замены для любой формы макроса.
  * Если токен препроцессора `#`, за которым следует идентификатор, лексически встречается в точке, с которой могла бы начинаться директива препроцессора, идентификатор не подлежит замене макрокомандой. 
  * Директива препроцессора следующей формы определяет объектный макрос, который заставляет каждый последующий экземпляр имени макроса заменяться списком замены токенов препроцессора, которые составляют оставшуюся часть директивы. Исключение составляет повторное определение макроса.
  > `#` _define-word_ _identifier_ _replacement-list_ _new-line_\
  > `#` `macro` _identifier_ _group_ _endm-line_\
  * Директива препроцессора следующей формы определяет функциональный макрос, с аргументами, синтаксически похожий на вызов функции. Параметры задаются необязательным списком идентификаторов, область действия которых простирается от их объявления в списке идентификаторов до символа новой строки, завершающего директиву препроцессора #define (в случае директивы `#macro`, до директивы `#endm`). Каждый последующий экземпляр функционально-подобного имени макроса, за которым следует (, так как следующий токен препроцессора вводит последовательность токенов препроцессора, которая заменяется списком аргументов в определении (вызовом макроса). Заменяемая последовательность токенов препроцессора завершается совпадающим ) токеном препроцессора, пропуская промежуточные совпадающие пары токенов препроцессора левой и правой круглых скобок. В последовательности токенов препроцессора, составляющих вызов функционального макроса, новая строка считается обычным символом пробела.
  > `#` _define-word_ _identifier_ _parameter-list_\
  >                   _replacement-list_ _new-line_\
  > `#` `macro` _identifier_ _parameter-list_ _group_ _endm-line_\
  * Последовательность токенов препроцессора, ограниченная наиболее подходящими внешними круглыми скобками, формирует список аргументов для макроса, подобного функции. Отдельные аргументы в списке разделяются токенами препроцессора запятой, но токены препроцессора запятой между соответствующими внутренними скобками не разделяют аргументы. Если в списке аргументов есть последовательности токенов препроцессора, которые в противном случае действовали бы как директивы препроцессора, поведение не определено.
  * Хотя директивы `#define` и `#set` имеют одинаковое поведение, рекомендуется использовать `#define` для первичного определения макроса, а `#set` для переопределения уже существующего макроса. В случае, если это правило будет нарушено, компилятор выдаст предупреждение.
  * Рекурсивные вызовы функциональных макросов разрешены, однако глубина рекурсии не должна превышать 256.

### 12.3.1. Подстановка аргументов 
* После определения аргументов для вызова функционального макроса происходит подстановка аргументов. Параметр в списке аргументов, если ему не предшествует токен препроцессора `#` или `##` или за ним не следует токен препроцессора `##` (см. ниже), заменяется соответствующим аргументом после того, как все макросы, содержащиеся в нем, были вычислены. Перед заменой маркеры препроцессора каждого аргумента полностью заменяются макросом, как если бы они составляли остальную часть файла препроцессора; никакие другие токены препроцессора недоступны.

### 12.3.2. Оператор `#`
* **Ограничения**
  * За каждым токеном `#` препроцессора в списке аргументов функционального макроса должен следовать параметр в качестве следующего токена препроцессора в списке аргументов.
* **Семантика**
  * Если в списке замещения параметру непосредственно предшествует токен препроцессора `#`, оба они заменяются токеном препроцессора с литералом из одной символьной строки, который содержит написание последовательности токенов препроцессора для соответствующего аргумента. Каждое появление пробела между токенами препроцессора аргумента становится одиночным символом пробела в литерале строки символов. Пробел перед первым токеном препроцессора и после последнего токена препроцессора, составляющего аргумент, удаляется. В противном случае исходное написание каждого токена препроцессора в аргументе сохраняется в литерале строки символов, за исключением специальной обработки для создания написания строковых литералов и символьных констант: символ `\` вставляется перед каждым символом `"` и `\` символьной константы. или строковый литерал (включая разделительные символы `"`). Если полученная замена не является допустимым литералом строки символов, поведение не определено. Строковый литерал символов, соответствующий пустому аргументу, равен `""`. Порядок вычисления операторов `#` и `##` не указан.

### 12.3.3. Оператор `##`
* **Ограничения**
  * Токен препроцессора `##` не должен встречаться в начале или в конце списка замены для любой формы определения макроса.
* **Семантика**
  * Встречая токен `##`, за которым следует параметр функционального макроса `X`, препроцессор удаляет пробел, предшествующий токену `##`, подставляет значение параметра `X` и заново обрабатывает полученную строку
  * Пример. Выполнение следующего кода приведёт к печати числа 123.
```c
#define AB 123
#define C(X) A ##X
void main() {
  print(C(B));
}
```

### 12.3.4. Области видимости макросов
* Область видимости макроса длится от момента его определения с помощью директивы `#define`, `#let` или `#macro` до момента его удаления с помощью директивы `#undef` (или до окончания единицы перевода).

## 12.4. Вычисления выражения 
* **Семантика**
  * При встрече директивы `#eval` происходит вычисление арифметического выражения, управляемого данной директивой.

## 12.5. Циклы
* **Ограничения**
  * Количество итераций одного цикла ограничено числом 32768. В случае превышения этого числа, процесс компиляции завершится с ошибкой
  * Выражение, управляющее циклом, должно быть целочисленным константным выражением, за исключением того, что: оно не должно содержать приведение типов.
* **Семантика**
  * Если условие директивы `#while` вычисляется как ноль, группа, которой она управляет, пропускается: директивы обрабатываются только через имя, которое определяет директиву, чтобы отслеживать уровень вложенных циклов; остальные токены препроцессора игнорируются, как и други токены препроцессора в группе. Иначе, обрабатывается группа, которой управляет директива, после чего процесс обработки директивы начинается заново.

# 13. Стандартная библиотека
  * Следующие идентификаторы являются объявленными на момент начала стадии трансляции 5.

## 13.1. Функции прерывания работы программы
* **Определение**
```c
void assert(bool expression, char[] message);
void проверить(bool expression, char[] message);
void ASSERT(bool expression, char[] message);
void ПРОВЕРИТЬ(bool expression, char[] message);
void exit(int code);
void выход(int code);
void EXIT(int code);
void ВЫХОД(int code);
```
* **Семантика**
  * Функция `assert` (`проверить`, `ASSERT`, `ПРОВЕРИТЬ`) выводит  в поток стандартного вывода параметр `message` если параметр `expression` имеет значние `false` и завершает программу с ошибкой.
  * Функция `exit` (`выход`, `EXIT`, `ВЫХОД`) завершает программу с кодом `code`.

## 13.2. Функции для работы с числами
* **Определение**
```c
float asin(float x);
float асин(float x);
float asin(float x);
float асин(float x);
float sin(float x);
float син(float x);
float SIN(float x);
float СИН(float x);
float cos(float x);
float кос(float x);
float COS(float x);
float КОС(float x);
float exp(float x);
float эксп(float x);
float EXP(float x);
float ЭКСП(float x);
float log(float x);
float лог(float x);
float LOG(float x);
float ЛОГ(float x);
float log10(float x);
float лог10(float x);
float LOG10(float x);
float ЛОГ10(float x);
float sqrt(float x);
float квкор(float x);
float SQRT(float x);
float КВКОР(float x);
float rand();
float случ();
float RAND();
float СЛУЧ();
int round(float x);
float округл(float x);
int ROUND(float x);
float ОКРУГЛ(float x);
```
* **Семантика**
  * Функция `asin` (`асин`, `ASIN`, `АСИН`) - функция, вычисляющая значение арксинуса (в радианах) от аргумента, переданного в параметре `x`.
  * Функция `sin` (`син`, `SIN`, `СИН`) - функция, вычисляющая значение синуса от аргумента (в радианах), переданного в параметре `x`.
  * Функция `cos` (`кос`, `COS`, `КОС`) - функция, вычисляющая значение косинуса от аргумента (в радианах), переданного в параметре `x`.
  * Функция `exp` (`эксп`, `EXP`, `ЭКСП`) - функция, вычисляющая значение экспоненты с основанием `e` от аргумента, переданного в параметре `x`.
  * Функция `log` (`лог`, `LOG`, `ЛОГ`) - функция, вычисляющая значение натурального логарифма от аргумента, переданного в параметре `x`.
  * Функция `log10` (`лог10`, `LOG10`, `ЛОГ10`) - функция, вычисляющая значение десятичного логарифма от аргумента, переданного в параметре `x`.
  * Функция `sqrt` (`квкор`, `SQRT`, `КВКОР`) - функция, вычисляющая значение квадратного корня от аргумента, переданного в параметре `x`.
  * Функция `rand` (`случ`, `RAND`, `СЛУЧ`) - функция, возвращающая случайное значение между 0 и 1 (включая оба конца).
  * Функция `round` (`округл`, `ROUND`, `ОКРУГЛ`) - функция, округляющая число, переданное в параметре `x`, до ближайшего целого. Если дробная часть числа равна 0.5, то число округляется вверх.

## 13.3. Функции для работы со строками
* **Определение**
```c
TODO
```

## 13.4. Функции для работы с потоками
* **Определение**
```c
int t_create(void* (*func)(void *));
int н_создать(void* (*func)(void *));
int T_CREATE(void* (*func)(void *));
int Н_СОЗДАТЬ(void* (*func)(void *));
int t_getnum();
int н_номер_нити();
int T_GETNUM();
int Н_НОМЕР_НИТИ();
int t_sleep(int seconds);
int н_спать(int seconds);
int T_SLEEP(int seconds);
int Н_СПАТЬ(int seconds);
void t_join(int thread);
void н_присоед(int thread);
void T_JOIN(int thread);
void Н_ПРИСОЕД(int thread);
void t_exit(int thread);
void н_конец(int thread);
void T_EXIT(int thread);
void Н_КОНЕЦ(int thread);
void t_init();
void н_начать();
void T_INIT();
void Н_НАЧАТЬ();
void t_destroy();
void н_закончить();
void T_DESTROY();
void Н_ЗАКОНЧИТЬ();
int t_sem_create(int level);
int н_создать_сем(int level);
int T_SEM_CREATE(int level);
int Н_СОЗДАТЬ_СЕМ(int level);
void t_sem_wait(int sem);
void н_вниз_сем(int sem);
void T_SEM_WAIT(int sem);
void Н_ВНИЗ_СЕМ(int sem);
void t_sem_post(int sem);
void н_вверх_сем(int sem);
void T_SEM_POST(int sem);
void Н_ВВЕРХ_СЕМ(int sem);
void t_msg_send(struct {int numTh; int data; } message);
void н_послать(struct {int numTh; int data; } message);
void T_MSG_SEND(struct {int numTh; int data; } message);
void Н_ПОСЛАТЬ(struct {int numTh; int data; } message);
struct {int numTh; int data; } t_msg_receive();
struct {int numTh; int data; } н_получить();
struct {int numTh; int data; } T_MSG_RECEIVE();
struct {int numTh; int data; } Н_ПОЛУЧИТЬ();
```
* **Семантика**
  * Функция `t_create` (`н_создать`, `T_CREATE`, `Н_СОЗДАТЬ`) создаёт процесс, исполняющий функцию, переданную в аргументе `func`
  * Функция `t_getnum` (`н_номер_нити`, `T_GETNUM`, `Н_НОМЕР_НИТИ`) возвращает номер текущего процесса.
  * Функция `t_sleep` (`н_спать`, `T_SLEEP`, `Н_СПАТЬ`) приостанавливает работу процесса на время (в секундах), указанное в аргументе `seconds`
  * Функция `t_join` (`н_присоед`, `T_JOIN`, `Н_ПРИСОЕД`) приостанавливает исполнение текущего процесса, пока не выполнится процесс с номером, переданным в аргументе `thread`
  * Функция `t_exit` (`н_конец`, `T_EXIT`, `Н_КОНЕЦ`) завершает исполнение текущего процесса
  * Функция `t_init` (`н_начать`, `T_INIT`, `Н_НАЧАТЬ`) **TODO**
  * Функция `t_destroy` (`н_закончить`, `T_DESTROY`, `Н_ЗАКОНЧИТЬ`) **TODO**
  * Функция `t_sem_create` (`н_создать_сем`, `T_SEM_CREATE`, `Н_СОЗДАТЬ_СЕМ`) создаёт семафор с изначально заданным уровнем, переданным в аргументе `level`. Функция возвращает номер созданного семафора
  * Функция `t_sem_wait` (`н_вниз_сем`, `T_SEM_WAIT`, `Н_ВНИЗ_СЕМ`) уменьшает уровень семафора с номером, переданным в аргументе `sem`, на 1. Если уровень становится отрицательным, текущий процесс "засыпает", иначе продолжает выполнение
  * Функция `t_sem_post` (`н_вверх_сем`, `T_SEM_POST`, `Н_ВВЕРХ_СЕМ`) увеличивает уровень семафора с номером, переданным в аргументе `sem`, на 1. Если уровень семафора был отрицательным, а стал положительным, один из процессов, ожидающих данный семафор, "просыпается"
  * Функция `t_msg_send` (`н_послать`, `T_MSG_SEND`, `Н_ПОСЛАТЬ`) посылает сообщение, переданное в аргументе `data` в процесс с номером, переданным в аргументе `numTh`
  * Функция `t_msg_recieve` (`н_получить`, `T_MSG_RECIEVE`, `Н_ПОЛУЧИТЬ`) пытается прочитать сообщение, адресованное данному процессу. Если таких несколько, возвращает первое из них. Если таковые отсутствуют, приостанавливает работу процесса до тех пор, пока сообщение не придёт

## 13.5. Функции для работы с файлами
* **Определение**
```c
file *fopen(char[] path, char[] mode);
file *фоткрыть(char[] path, char[] mode);
file *FOPEN(char[] path, char[] mode);
file *ФОТКРЫТЬ(char[] path, char[] mode);
int fgetc(file *f);
int фчитать_символ(file *f);
int FGETC(file* f);
int ФЧИТАТЬ_СИМВОЛ(file *f);
int fputc(int c, file* f);
int фписать_символ(int c, file *f);
int FPUTC(int c, file *f);
int ФПИСАТЬ_СИМВОЛ(int c, file *f);
int fclose(file *f);
int фзакрыть(file *f);
int FCLOSE(file *f);
int ФЗАКРЫТЬ(file *f);
```
* **Семантика**
  * Функция `fopen` (`фоткрыть`, `FOPEN`, `ФОТКРЫТЬ`) открывает файл, путь к которому указан в параметре `path`, в режиме, указанном в параметре `mode`. Возвращает указатель на файл, если файл был открыт успешно, и `NULL` в противном случае.
  * Возможные режимы, указываемые в параметре `mode`:
    * `r` - открыть файл для чтения
    * `w` - очистить файл или создать новый файл для записи
    * `a` - открыть или создать файл для записи в конец файла
    * `rb` - открыть бинарный файл для чтения
    * `wb` - очистить бинарный файл или создать новый бинарный файл для записи
    * `ab` - открыть или создать бинарный файл для записи в конец файла
    * `r+` - открыть файл для обновления (чтения и записи)
    * `w+` - очистить бинарный файл или создать новый бинарный файл для обновления
    * `a+` - открыть или создать бинарный файл для обновления (запись в конец файла)
    * `rb+` или `r+b` - открыть бинарный файл для обновления (чтения и записи)
    * `wb+` или `w+b` - очистить бинарный файл или создать новый бинарный файл для обновления
    * `ab+` или `a+b` - открыть или создать бинарный файл для обновления (запись в конец файла)
  * Открытие файла в режиме чтения (`r`) завершается ошибкой в случае, если файл не существует или не может быть прочитан.
  * Функция `fgetc` (`фчитать_символ`, `FGETC`, `ФЧИТАТЬ_СИМВОЛ`) читает символ из файла, переданного в параметре `f`. Возвращает прочитанный символ, если чтение прошло успешно, и `-1` в противном случае.
  * Функция `fputc` (`фписать_символ`, `FPUTC`, `ФПИСАТЬ_СИМВОЛ`) - записывает символ, переданный в параметре `c` в файл, переданный в параметре `f`. Возвращает записанный символ, если запись прошла успешно, и `-1` в противном случае.
  * `fclose`, `фзакрыть`, `FCLOSE`, `ФЗАКРЫТЬ` - закрывает файл, переданный в параметре `f`. Возвращает `0`, если закрытие прошло успешно, и `-1` в противном случае.

## 13.6. Функции для работы со стандартными вводом и выводом
* **Определение**
```c
int printf(char[] format, ...);
int печатьф(char[] format, ...);
int PRINTF(char[] format, ...);
int ПЕЧАТЬФ(char[] format, ...);
void print(...);
void печать(...);
void PRINT(...);
void ПЕЧАТЬ(...);
void printid(...);
void печатьид(...);
void PRINTID(...);
void ПЕЧАТЬИД(...);
void getid(...);
void читатьид(...);
void GETID(...);
void ЧИТАТЬИД(...);
```
* **Ограничения**
  * Указанные функции умеют работать только с объектами следующиъ типов: **арифметические**; **массив** типа, указанного в ограничениях; **структура**, содержащая только типы, указанные в ограничениях.
* **Семантика**
  * Функция `printf` (`печатьф`, `PRINTF`, `ПЕЧАТЬФ`) - печатает строку, формат которой задан в параметре `format`, в стандартный поток вывода.
  * Функция `print` (`печать`, `PRINT`, `ПЕЧАТЬ`) - печатает переменную в стандартный поток вывода. 
  * Функция `printid` (`печатьид`, `PRINTID`, `ПЕЧАТЬИД`) - печатает имя переменной и переменную в стандартный поток вывода.
  * Функция `getid` (`читатьид`, `GETID`, `ЧИТАТЬИД`) - печатает имя переменной в стандартный поток вывода, читает переменную из стандартного потока ввода.
  * Функции `print` может печатать переменные следующих типов в следующем формате:
    * **целочисленного** типа - печатается десятичное представление числа
    * **символьного** типа - печатается символ, хранящийся в переменной
    * **вещественного** типа - печатается десятичное представление числа с плавающей запятой, не более 20 знаков перед запятой и не более 15 знаков после запятой
    * **массива элементов типа T**, где T - тип, который может быть напечатан функцией `print`. Печатается каждый элемент массива, в качестве разделителя выступает ` `
    * **структуры**, элементами которой являются только переменные типов, которые могут быть напечатаны функцией `print`. Печатается символ `{`, за которым следует список из всхе полей структуры, в качестве разделителя выступает `, `, после чего следует символ `}`
  * Функция `printid` может печатать переменные тех же типов, что и функция `print`. Формат вывода отличается только тем, что перед выводом переменной на экран, выводится имя переменной
  * Функция `getid` печатает имя переменной, как функция `printid`, после чего ожидает ввод переменной в формате, в котором её выводит функция `print`.
  * В функции `printf` символы из строки `format` обрабатываются как обычные символы, за исключением следующих сочетаний символов:
    * `%i`, `%ц` - вместо этих символов печатается значение аргумента, имеющего **целочисленный** тип
    * `%c`, `%л` - вместо этих символов печатается значение аргумента, имеющего **символьный** тип
    * `%f`, `%в` - вместо этих символов печатается значение аргумента, имеющего **вещественный** тип
    * `%s`, `%с` - вместо этих символов печатается значение аргумента, имеющего тип **массива элементов символьного типа**, воспринимающегося как строка
    * `%%` - вместо этих символов печатается `%`
  * В случае, если в строке `format` содержатся упомянутые выше сочетания символов, то (за исключением сочетания `%%`) последующие аргументы функции должны содержать в себе объекты соответствующих типов в соответствующем порядке.
